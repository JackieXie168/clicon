/*
 *  CVS Version: $Id: clicon_err.c,v 1.10 2013/09/05 20:07:36 olof Exp $
 *
  Copyright (C) 2009-2013 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 * Errors may be syslogged using LOG_ERR, and printed to stderr, as controlled
 * by clicon_err_init and clicon_log_init
 * global error variables are set:
 *  clicon_errno, clicon_suberrno, clicon_err_reason.
 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdarg.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <syslog.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <sys/types.h>

#include "clicon_log.h"
#include "clicon_queue.h"
#include "clicon_chunk.h"
#include "clicon_err.h"

/*
 * Types
 */
struct errvec{
    char *ev_str;
    int   ev_err;
};

struct err_state{
    int  es_errno;
    int  es_suberrno;
    char es_reason[ERR_STRLEN];
};

/*
 * Variables
 */
int clicon_errno  = 0;    /* See enum clicon_err */
int clicon_suberrno  = 0; /* Corresponds to errno.h */
char clicon_err_reason[ERR_STRLEN] = {0, };

/* Local variables */
static int err_syslog = 0; /* print errors on syslog */
static int err_stderr = 0; /* print errors on stderr */

/*
 * Error descriptions. Must stop with NULL element.
 */
static struct errvec EV[] = {
    {"Database error",      OE_DB},
    {"Demon error",        OE_DEMON},
    {"Event error",        OE_EVENTS},
    {"Config error",        OE_CFG},
    {"Protocol error",    OE_PROTO},
    {"Regexp error",    OE_REGEX},
    {"UNIX error",    OE_UNIX},
    {"Syslog error",    OE_SYSLOG},
    {"Routing demon error",    OE_ROUTING},
    {"Plugins",    OE_PLUGIN},
    {"Undefined",    OE_UNDEF},
    {NULL,                     -1}
};

/* XXX: hardcoded to QUAGGA, move to app-layer */
static struct errvec QV[] = {
    {"QUAGGA_SUCCESS",              0},
    {"QUAGGA_WARNING",              1},
    {"QUAGGA_ERR_NO_MATCH",         2},
    {"QUAGGA_ERR_AMBIGUOUS",        3},
    {"QUAGGA_ERR_INCOMPLETE",       4},
    {"QUAGGA_ERR_EXEED_ARGC_MAX",   5},
    {"QUAGGA_ERR_NOTHING_TODO",     6},
    {"QUAGGA_COMPLETE_FULL_MATCH",  7},
    {"QUAGGA_COMPLETE_MATCH",       8},
    {"QUAGGA_COMPLETE_LIST_MATCH",  9},
    {"QUAGGA_SUCCESS_DAEMON",      10},
    {"QUAGGA_NO_CONTACT",          11},
    {NULL,            -1}
};



/*
 * Applications define how errors are signalled.
 * On FILE, syslog(LOG_ERR), or not at all.
 * If not at all, the app can choose to print all error messages itself.
 * Use _either_ syslog, stderr or neither. Dont use both.
 */
int
clicon_err_init(int use_syslog, int use_stderr)
{
    err_syslog = use_syslog;
    err_stderr = use_stderr;
    return 0;
}

static char *
clicon_strerror1(int err, struct errvec vec[])
{
    struct errvec *ev;

    for (ev=vec; ev->ev_err != -1; ev++)
	if (ev->ev_err == err)
	    break;
    return ev?(ev->ev_str?ev->ev_str:"unknown"):"OSR unknown error";
}

/*
 * clicon_err_reset
 * Clear error state and get on with it.
 * (Non-fatal error and you wish to continue)
 */
int
clicon_err_reset(void)
{
    clicon_errno = 0;
    clicon_suberrno = 0;
    memset(clicon_err_reason, 0, ERR_STRLEN);
    return 0;
}

static int
err_print1(FILE *f, char *prestr, int time, 
	   int errno, int suberrno, char *reason)
{
    struct timeval tv;
    struct tm *tm;

    if (time){
	gettimeofday(&tv, NULL);
	tm = localtime((time_t*)&tv.tv_sec);
	fprintf(f, "%s %2d %02d:%02d:%02d: ", 
		mon2name(tm->tm_mon), tm->tm_mday,
		tm->tm_hour, tm->tm_min, tm->tm_sec);
    }
    if (prestr && strlen(prestr))
	fprintf(f, "%s: ", prestr);
    if (errno)
	fprintf(f, "%s: ", clicon_strerror(errno));
    switch (errno){
    case OE_ROUTING: 
	if (suberrno)
	    fprintf(f, "%s: ", clicon_strerror1(suberrno, QV));
	break;
    default:
	if (suberrno)
	    fprintf(f, "%s: ", strerror(suberrno));
	break;
    }
    if (strlen(reason)){
	fprintf(f, "%s", reason);
	if (index(reason, '\n') == NULL)
	    fprintf(f, "\n");
    }
    else
	fprintf(f, "\n");
    clicon_err_reset();
    return 0;
}


/*
 * clicon_err_fn
 * Library routines should call this function when an error occurs.
 * The function does he following:
 * - Logs to syslog with LOG_ERR
 * - Set global error variable name clicon_errno
 * - Set global reason string clicon_err_reason
 * NOTE: err direction (syslog and/or stderr) controlled by clicon_err_init and 
 * clicon_log_init()
 */
int
clicon_err_fn(const char *fn, const int line, int err, int suberr, char *reason, ...)
{
    va_list args;

    clicon_errno = err;
    clicon_suberrno = suberr;
    va_start(args, reason);
    vsnprintf(clicon_err_reason, ERR_STRLEN, reason, args);
    va_end(args);
    if (err_syslog){
	if (suberr)
	    syslog(LOG_MAKEPRI(LOG_USER, LOG_ERR), "%s: %s: %s\n",
		   clicon_strerror(err),
		   clicon_err_reason,
		   strerror(suberr));
	else
	    syslog(LOG_MAKEPRI(LOG_USER, LOG_ERR), "%s: %s\n",
		   clicon_strerror(err),
		   clicon_err_reason);
    }
    if (err_stderr)
	err_print1(stderr, NULL, 0, err, suberr, clicon_err_reason);
    return 0;
}



/*
 * clicon_strerror
 * Translate from numeric error to string representation
 */
char *
clicon_strerror(int err)
{
    return clicon_strerror1(err, EV);
}

/*
 * Print error messages (syslog style) to a file (eg stderr)
 * Only top-level applications use this to print an error that occurred
 * with clicon_err().
 * NOTE: use clicon_err() to indicate an error in a library routine.
 */
int
clicon_err_print(FILE *f, char *prestr)
{
    return err_print1(f, prestr, 1, clicon_errno, clicon_suberrno, clicon_err_reason);
}

void*
clicon_err_save(void)
{
    struct err_state *es;

    if ((es = chunk(sizeof(*es), NULL)) == NULL)
	return NULL;
    es->es_errno = clicon_errno;
    es->es_suberrno = clicon_suberrno;
    strncpy(es->es_reason, clicon_err_reason, ERR_STRLEN-1);
    return (void*)es;
}

int
clicon_err_restore(void* handle)
{
    struct err_state *es;

    es = (struct err_state *)handle;
    clicon_errno = es->es_errno;
    clicon_suberrno = es->es_suberrno;
    strncpy(clicon_err_reason, es->es_reason, ERR_STRLEN-1);
    unchunk(es);
    return 0;
}
