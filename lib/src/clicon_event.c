/*
 *
  Copyright (C) 2009-2015 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 * Event handling and loop
 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>

#include "clicon_queue.h"
#include "clicon_chunk.h"
#include "clicon_log.h"
#include "clicon_err.h"
#include "clicon_event.h"

/*
 * Constants
 */
#define EVENT_STRLEN 32

/*
 * Types
 */
struct event_data{
    struct event_data *e_next;     /* next in list */
    int (*e_fn)(int, void*);            /* function */
    enum {EVENT_FD, EVENT_TIME} e_type;        /* type of event */
    int e_fd;                      /* File descriptor */
    struct timeval e_time;         /* Timeout */
    void *e_arg;                   /* function argument */
    char e_string[EVENT_STRLEN];             /* string for debugging */
};

/*
 * Internal variables
 */
static struct event_data *ee = NULL;
static struct event_data *ee_timers = NULL;

/*
 * Register a callback function when something occurs on a file descriptor.
 * When an input event occurs on file desriptor <fd>, 
 * the function <fn> shall be called  with argument <arg>.
 * <str> is a debug string for logging.
 */
int
event_reg_fd(int fd, int (*fn)(int, void*), void *arg, char *str)
{
    struct event_data *e;

    if ((e = (struct event_data *)chunk(sizeof(struct event_data), str)) == NULL){
	clicon_err(OE_EVENTS, errno, "chunk");
	return -1;
    }
    memset(e, 0, sizeof(struct event_data));
    strncpy(e->e_string, str, EVENT_STRLEN);
    e->e_fd = fd;
    e->e_fn = fn;
    e->e_arg = arg;
    e->e_type = EVENT_FD;
    e->e_next = ee;
    ee = e;
    clicon_debug(2, "%s, registering %s", __FUNCTION__, e->e_string);
    return 0;
}

/*
 * event_unreg_fd
 * Deregister an event.
 * If the socket and function match, deregister.
 */
int
event_unreg_fd(int s, int (*fn)(int, void*))
{
    struct event_data *e, **e_prev;
    int found = 0;

    e_prev = &ee;
    for (e = ee; e; e = e->e_next){
	if (fn == e->e_fn && s == e->e_fd) {
	    found++;
	    *e_prev = e->e_next;
	    unchunk(e);
	    break;
	}
	e_prev = &e->e_next;
    }
    return found?0:-1;
}

/*
 * Sort into internal event list
 * Given an absolute timestamp, register function to call.
 */
int
event_reg_timeout(struct timeval t,  int (*fn)(int, void*), 
		  void *arg, char *str)
{
    struct event_data *e, *e1, **e_prev;

    if ((e = (struct event_data *)chunk(sizeof(struct event_data), "event")) == NULL){
	clicon_err(OE_EVENTS, errno, "chunk");
	return -1;
    }
    memset(e, 0, sizeof(struct event_data));
    strncpy(e->e_string, str, EVENT_STRLEN);
    e->e_fn = fn;
    e->e_arg = arg;
    e->e_type = EVENT_TIME;
    e->e_time = t;
    /* Sort into right place */
    e_prev = &ee_timers;
    for (e1=ee_timers; e1; e1=e1->e_next){
	if (timercmp(&e->e_time, &e1->e_time, <))
	    break;
	e_prev = &e1->e_next;
    }
    e->e_next = e1;
    *e_prev = e;
    clicon_debug(2, "event_reg_timeout: %s", str); 
    return 0;
}

/*
 * event_unreg_timeout
 * Deregister an event.
 * If the function and argument match, deregister.
 */
int
event_unreg_timeout(int (*fn)(int, void*), void *arg)
{
    struct event_data *e, **e_prev;
    int found = 0;

    e_prev = &ee_timers;
    for (e = ee_timers; e; e = e->e_next){
	if (fn == e->e_fn && arg == e->e_arg) {
	    found++;
	    *e_prev = e->e_next;
	    unchunk(e);
	    break;
	}
	e_prev = &e->e_next;
    }
    return found?0:-1;
}

/*
 * event_loop
 *
 * Dispatch file descriptor events (and timeouts) by invoking callbacks.
 * There is an issue with fairness that timeouts may take over all events
 * One could try to poll the file descriptors after a timeout?
 */
int
event_loop(void)
{
    struct event_data *e, *e_next;
    int n;
    struct timeval t, t0;
    fd_set fdset;
    int retval = -1;

    while (1){
	FD_ZERO(&fdset);
	for (e=ee; e; e=e->e_next)
	    if (e->e_type == EVENT_FD)
		FD_SET(e->e_fd, &fdset);

	if (ee_timers != NULL){
	    gettimeofday(&t0, NULL);
	    timersub(&ee_timers->e_time, &t0, &t); 
	    if (t.tv_sec < 0)
		n = 0;
	    else
		n = select(FD_SETSIZE, &fdset, NULL, NULL, &t); 
	}
	else
	    n = select(FD_SETSIZE, &fdset, NULL, NULL, NULL); 
	if (n == -1) {
#if 0 /* You may want to be more elaborate here */
	    if (errno == EINTR)
		continue;
#endif
	    if (errno == EINTR){
		clicon_debug(1, "%s select: %s", __FUNCTION__, strerror(errno));
		retval = 0;
		goto err;
	    }
	    else
		clicon_err(OE_EVENTS, errno, "%s select", __FUNCTION__);
	    goto err;
	}
	if (n==0){ /* Timeout */
	    e = ee_timers;
	    ee_timers = ee_timers->e_next;
	    clicon_debug(2, "%s timeout: %s[%x]", 
		    __FUNCTION__, e->e_string, e->e_arg);
	    if ((*e->e_fn)(0, e->e_arg) < 0){
		unchunk(e);
		goto err;
	    }
	    unchunk(e);
	}
	for (e=ee; e; e=e_next){
	    e_next = e->e_next;
	    if(e->e_type == EVENT_FD && FD_ISSET(e->e_fd, &fdset)){
		clicon_debug(2, "%s: socket: %s[%x]", 
			__FUNCTION__, e->e_string, e->e_arg);
		if ((*e->e_fn)(e->e_fd, e->e_arg) < 0)
		    goto err;
	    }
	}
	continue;
      err:
	break;
    }
    clicon_debug(1, "%s done:", __FUNCTION__);
    return retval;
}

