/*
 *
  Copyright (C) 2009-2015 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 * Lvalue map
 */

/*
 * How to use an lmap iterator:
 * {
 *   struct lm_iter *li;
 *   char *key, *fmt, *neg, *opt;
 * 
 *   if ((li = lvmap_iter_inet(lm)) == NULL)
 *      return -1;
 *   while ((err = lvmap_iter_next(li, &key, &fmt)) == 0){
 *      //Use key and fmt
 *      free(key); free(fmt);    
 *   }
 *   free(li);
 *   if (err < 0)
 *     ; // err-handling 
 * }
 * NOTES:
 * 1. If thread, db may change between usages of key and fmt
 * 2. The lvmap may _not_ change.
 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <inttypes.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <assert.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <regex.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include "clicon_string.h"
#include "clicon_queue.h"
#include "clicon_hash.h"
#include "clicon_db.h"
#include "clicon_chunk.h"
#include "clicon_err.h"
#include "clicon_handle.h"
#include "clicon_dbspec_key.h"
#include "clicon_lvalue.h"
#include "clicon_dbutil.h"
#include "clicon_lvmap.h"


static int
lvmap_get_dbsingle(char *dbname,
		   struct lvmap *lm,
		   char *basekey,
		   char *matched,
		   const char *label,
		   struct lvmap_dbkeyent **keys,
		   int *nkeys,
		   int addempty		/* Add empty keys to returned list */
		   )
{
  char *key;
  struct lvmap_dbkeyent *newkeys;
  char *lvec = NULL;  /* Value vector consisting of lvalues */
  size_t len;

  /* Check for existance of key in db unless it's a comment */
  if (!key_iscomment (basekey)) {
    if (db_get_alloc(dbname, basekey, (void*)&lvec, &len) < 0)
      goto quit;
    if (lvec)
      free(lvec);
    if (len == 0 && !addempty)	/* Don't add empty keys unless instructed to */
      return 0; 
  }
  else
      len = 0; /* XXX: Not sure */
  
  /* Just copy the basekey */
  key = chunkdup (basekey, strlen(basekey)+1, label);
  if (key == NULL)
    goto quit;

  /* Re-size the vector to 'nkeys' + new key */
  newkeys = rechunk (*keys, 
		     (*nkeys + 1 ) * sizeof (struct lvmap_dbkeyent), 
		     label);
  if (newkeys == NULL)
    goto quit;

  /* Append new key to vector */
  if (!key_iscomment (basekey) && addempty && len == 0 ) /* NULL key if empty db-key */
    newkeys[*nkeys].ld_dbkey = NULL;
  else
    newkeys[*nkeys].ld_dbkey = key;
  newkeys[*nkeys].ld_matched = matched ? chunkdup(matched, strlen(matched)+1, label) : NULL;
  newkeys[*nkeys].ld_lm = lm;
  *keys = newkeys;
  (*nkeys)++;
  
  /* unchunk_group(__FUNCTION__); */
  return *nkeys;

 quit:
  /* unchunk_group(__FUNCTION__); */
  return -1;
}


/* 
 * lvmap_get_dbvector_sort
 * qsort function for lvmap_get_dbvector.
 * Sorts vector values based on the "_SEQ" variable if it exist. 
 */
int
lvmap_get_dbvector_sort(const void *p1, const void *p2)
{
  int retval = 0;
  int seq1;
  int seq2;
  cg_var *v1;
  cg_var *v2;
  cvec *vh1 = NULL;
  cvec *vh2 = NULL;
  struct db_pair *dp1 = (struct db_pair *)p1;
  struct db_pair *dp2 = (struct db_pair *)p2;

  if ((vh1 = lvec2cvec (dp1->dp_val, dp1->dp_vlen)) == NULL)
    goto catch;
  if ((vh2 = lvec2cvec (dp2->dp_val, dp2->dp_vlen)) == NULL)
    goto catch;

  if ((v1 = cvec_find (vh1, "_SEQ")) == NULL)
    goto catch;
  if ((v2 = cvec_find (vh2, "_SEQ")) == NULL)
    goto catch;

  seq1 = cv_int_get(v1);
  seq2 = cv_int_get(v2);
  retval = seq1 - seq2;
  
  /* Fall through */
    
 catch:
  if (vh1)
    cvec_free(vh1);
  if (vh2)
    cvec_free(vh2);

  return retval;
}

int
lvmap_get_dbvector(char *dbname,
		   struct lvmap *lm,
		   char *basekey,
		   const char *label,
		   struct lvmap_dbkeyent **keys,
		   int *nkeys,
		   int addempty		/* Add empty keys to returned list */
		   )
{
  int i;
  char *key;
  char *vkey;
  int npairs;
  struct db_pair *pairs;


  assert (key_isanyvector(basekey));
  
  key = basekey;
  /* Compose key regexp matching vector keys */
  vkey = db_gen_rxkey(key, __FUNCTION__);
  if (vkey == NULL)
      goto quit;

  /* Get all keys/values for vector */
  npairs = db_regexp(dbname, vkey, __FUNCTION__, &pairs, 0);
  if (npairs < 0)
    goto quit;

  if (npairs == 0) {
    if (addempty)
      if (lvmap_get_dbsingle(dbname, lm, key, NULL, label, keys, nkeys, addempty) < 0)
	goto quit;
    goto done;
  }
  
  /* Sort vector */
  qsort (pairs, npairs, sizeof (struct db_pair), lvmap_get_dbvector_sort);
  
  /* Loop through list and pass on to lvmap_get_dbsingle() */
  for (i = 0; i < npairs; i++) {
      if (lvmap_get_dbsingle(dbname, lm, pairs[i].dp_key, pairs[i].dp_matched, label, keys, nkeys, addempty) < 0)
      goto quit;
  }
  
 done:
  unchunk_group(__FUNCTION__);
  return *nkeys;

 quit:
  unchunk_group(__FUNCTION__);
  return -1;
}



/*
 * lvmap_get_dbregex_sort
 * qsort function for lvmap_get_dbregex. 
 * Normal string compare will not sort "numbered keys" properly. For example
 * "my.key.10" will come before "my.key.2". This sort function uses the
 * following logic to solve that. It splits the keys delimited by '.'
 * and compares each section individually. If a section does not match, 
 * it will compare the section without any trailing digits and if it 
 * matches, then compare trailing digits as numbers.
 */
int
lvmap_get_dbregex_sort (const void *p1, const void *p2)
{
  int i;
  int retval = 0;
  int nv1, nv2;
  char *ptr1, *ptr2;
  char **v1 = NULL;
  char **v2 = NULL;
  char *s1 = ((struct db_pair *)p1)->dp_key;
  char *s2 = ((struct db_pair *)p2)->dp_key;
  
  if ((v1 = clicon_sepsplit (s1, ".", &nv1, __FUNCTION__)) == NULL)
    goto catch;
  if ((v2 = clicon_sepsplit (s2, ".", &nv2, __FUNCTION__)) == NULL)
    goto catch;

  for (i = 0; i < ((nv1 < nv2) ? nv2 : nv1); i++) {

    if (i >= nv1 || i >= nv2) {
      retval = nv1 - nv2;
      break;
    }
    
    if (strcmp (v1[i], v2[i]) == 0)
      continue;

    ptr1 = v1[i] + strlen(v1[i])-1;
    while (ptr1 >= v1[i] && isdigit(*ptr1))
      ptr1--;
    ptr1++;

    ptr2 = v2[i] + strlen(v2[i])-1;
    while (ptr2 >= v2[i] && isdigit(*ptr2))
      ptr2--;
    ptr2++;

    if ((ptr1-v1[i]) == (ptr2-v2[i]) && !strncmp(v1[i], v2[i], (ptr1-v1[i])))
      retval = atoi(ptr1) - atoi(ptr2);
    else
      retval = strcmp (v1[i], v2[i]);
    break;
  }

  /* Fall through */
 catch:
  unchunk_group (__FUNCTION__);

  return retval;
}

/*
* lvmap_get_dbkeys
* Return a list of keys in a database using an lvmap order.
* The key is a vector of char* pointers terminated by NULL.
* The list should be freed as a whole with:
*      unchunk_group(label);
*/
int
lvmap_get_dbkeys(struct lvmap *lmap,
		 char *dbname,
		 char *keyprefix,
		 const char *label,  	/* For freeing keys chunk */
		 struct lvmap_dbkeyent **keys,
		 int addempty		/* Add empty keys to returned list */
		 ) 
{
  int nkeys;
  int rxkey;
  char *key;
  char *basekey; 
  struct lvmap *lm;
 
  /* Allocate a 1-entry char** pointer and set it's pointer to NULL */
  if ((*keys = chunk(sizeof(struct lvmap_dbkeyent *), label)) == NULL){
    clicon_err(OE_DB, errno, "lvmap_get_dbkeys: chunk");
    return -1;
  }
  *keys = NULL;
  nkeys = 0;

  /* Loop through lvmap */
  for (lm=lmap; lm; lm++){
      
      key = lm->lm_key;
    if ( key  == NULL) /* End of lvmap */
      break;
    
    rxkey = 0;
    if (key[0] == '^') {
	rxkey = 1;
	key++;
    }
    basekey =	/* Create base key */
	chunk_sprintf(__FUNCTION__, "%s%s%s", 
		      rxkey ? "^" : "",
		      keyprefix ? keyprefix : "",
		      key);
    if (basekey == NULL)
      goto quit;

    /* Call relevant sub-routine to append new db-key(s) to list */
    if (key_isanyvector (basekey)) {	/* Vector key */
      if (lvmap_get_dbvector(dbname, lm, basekey, label, keys, &nkeys, addempty) < 0)
	goto quit;
    } else {					/* Single key */
      if (lvmap_get_dbsingle(dbname, lm, basekey, NULL, label, keys, &nkeys, addempty) < 0)
	goto quit;
    }

  } /* for() */

  unchunk_group (__FUNCTION__);
  return nkeys;
  
 quit:
  unchunk_group (label);
  unchunk_group (__FUNCTION__);
  return -1;
}




/* lvmap_match_key
* Given an lvmap and a key, return the index of the first entry in lvmap
* that matches the key.
* or -1 which signals not found
* Return also found lvalue in lmx if given.
*/
int
lvmap_match_key(struct lvmap *lmap, char *dbkey, struct lvmap **lmx)
{
  int idx;
  int status;
  char *key;
  static regex_t re;
  struct lvmap *lm;

  /* Loop through lvmap */
  for (idx=0, lm=lmap; lm; idx++, lm++){
    if (lm->lm_key  == NULL) /* End of lvmap */
      break;

    if(strcmp("router.bgp.neighbor[]",lm->lm_key)==0)
	puts(lm->lm_key);

  /* Regexp key or vector key */
    if (key_isregex(lm->lm_key) || key_isanyvector (lm->lm_key)) {
	
	if (key_isanyvector(lm->lm_key)) 
	    key = db_gen_rxkey(lm->lm_key, __FUNCTION__);
	else
	    key = chunk_sprintf(__FUNCTION__, "%s$", lm->lm_key);
	if (key == NULL)
	    goto quit;
	
	status = regcomp(&re, key, REG_NOSUB|REG_EXTENDED);
	if (status != 0)
	    goto quit;
	status = regexec(&re, dbkey, (size_t) 0, NULL, 0);
	regfree(&re);
	
	unchunk (key);
	if (status == 0) /* Match */
	    break;
	
    } else {	/* Single key */
	
	if (!strcmp (lm->lm_key, dbkey))
	    break;
    }
    
  } /* for() */

  if (lm->lm_key == NULL) /* No match */
    goto quit;

  unchunk_group (__FUNCTION__);
  if (lmx)
      *lmx = lm;
  return idx;

 quit:
  unchunk_group (__FUNCTION__);
  return -1;
}



/*
 * lvmap_print
 * Given a database and an lval-map (key, format pair-vector), 
 * go through all key mappings in lval-map and show print them on f.
 * The function db_lv_string is called to do the actual translation.
 */
static char *
lvmap_print_str(FILE *f, char *dbname, struct lvmap *lmap,
		char *keyprefix)
{
    char *str;
    char *dbkey, *matched, *fmt, *neg;
    char *output, *tmps;
    void *opt;
    int op;
    int i, j;
    int nkeys;
    int nonce = 0;
    struct lvmap **tmp, **lmonce = NULL;
    struct lvmap_dbkeyent *keys;

    output = chunkdup("", 1, NULL);
    
    nkeys = lvmap_get_dbkeys(lmap, dbname, keyprefix, __FUNCTION__, &keys, 1);
    for (i = 0; i < nkeys; i++) {
	
      dbkey = keys[i].ld_dbkey;
      matched = keys[i].ld_matched;
      fmt = keys[i].ld_lm->lm_fmt;
      neg = keys[i].ld_lm->lm_neg;
      op = keys[i].ld_lm->lm_op;
      opt = keys[i].ld_lm->lm_opt;

      /* Check if we've already done an ONCE-operation */
      if (LVPRINT_ONCE(op)) {
	  for (j=0; j < nonce; j++) 
	      if (keys[i].ld_lm == lmonce[j])
		  break;
	  if (j < nonce)
	      continue;
      }

      switch (op) {
      case LVPRINT_COMMENT:
	output = chunk_strncat(output, fmt, strlen(fmt), NULL);
	output = chunk_strncat(output, "\n", 1, NULL);
	break;

      case LVPRINT_CMD:
      case LVPRINT_CMD_ONCE:
        if (dbkey == NULL) {
	  if (neg) {
	    output = chunk_strncat(output, neg, strlen(neg), NULL);	
	    output = chunk_strncat(output, "\n", 1, NULL);
	  }
	} else {
	  if ((str = db_lv_string(dbname, dbkey, fmt))) {
	    output = chunk_strncat(output, str, strlen(str), NULL);	
	    output = chunk_strncat(output, "\n", 1, NULL);
	    free(str);
	  }
	}
	break;

      case LVPRINT_MODE:
      case LVPRINT_MODE_ONCE:
      case LVPRINT_MODE_CONDITIONAL:
      case LVPRINT_MODE_ONCE_CONDITIONAL:
        if (dbkey == NULL) {
	  if (neg) {
	    output = chunk_strncat(output, neg, strlen(neg), NULL);	
	    output = chunk_strncat(output, "\n", 1, NULL);
	  }
	} else {
	  str = db_lv_string(dbname, dbkey, fmt);
	  assert(opt != NULL);
	  keyprefix = matched ? matched : dbkey;
	  tmps = lvmap_print_str (f, dbname, (struct lvmap *)opt,
				 neg ? neg : keyprefix);
	  if (str && (tmps || ! LVPRINT_CONDITIONAL(op))) {
	      output = chunk_strncat(output, str, strlen(str), NULL);	
	      output = chunk_strncat(output, "\n", 1, NULL);
	  }
	  if (str)
	      free(str);
	  if (tmps) {
	      output = chunk_strncat(output, tmps, strlen(tmps), NULL);
	      unchunk(tmps);
	  }
	}
        break;


      case LVPRINT_FUNC:
	{
	  switch((intptr_t)opt) {
	  case LVPRINT_FUNC_GRUB: {
#ifdef notanymore
	    int ent;
	    char *s;
	    struct var_head *vh;
	    struct osr_grubconf *g;
	    
	    if (dbkey == NULL)
	      break;
	    if ((g = osr_grub_parsemenu()) == NULL)
	      break;
	    
	    for (ent = 0; ent < g->nent; ent++) {
	      if ((vh = g->ent[ent]) == NULL)
		continue;
	      if(var_find(vh, "title")) {
		if((s = lvmap_var_fmt(vh, fmt))) {
		  output = chunk_strncat(output, s, strlen(s), NULL);	
		  output = chunk_strncat(output, "\n", 1, NULL);
		  free(s);
		}
	      }	   
	    }
#endif /* notanymore */
	    break;
	  }
	  default:
	      break;
	      
	      
	  }
	}
      default:
	  break;
      }
      
      /* Record lvmap entry if we have a ONCE-operation */
      if (LVPRINT_ONCE(op)) {
	  if ((tmp = rechunk(lmonce, (nonce+1)*sizeof(*lmonce), __FUNCTION__))){
	      lmonce = tmp;
	      lmonce[nonce] =  keys[i].ld_lm;
	      nonce++;
	  }
      }
    }
    
    if (keys)
	unchunk(keys);
    if (lmonce)
	unchunk(lmonce);

    return output;
}  

int
lvmap_print(FILE *f, char *dbname, struct lvmap *lmap, char *keyprefix)
{
    char *str;

    str = lvmap_print_str(f, dbname, lmap, keyprefix);
    if (str != NULL) {
	fprintf(f, "%s", str);
	unchunk(str);
    }
    return 0;
}



/*
 * Generate string based on variable list and a string format.
 *
 * Variable substitutions is specified in format as $varname. It is
 * a also possible to add conditional format for a variable by appending
 * it to within curly brackets, i.e. $varname{some text $$ and again $$}.
 * The value for $varname will substitute $$. If $varname does not
 * exist, nothing will be generated. The actual variable value does not
 * have to be included in the variable format. The existance of the 
 * variable can simply a condition for some text, i.e. $varname{some text} 
 *
 * Arguments:
 *	head	  	- Variable head structure
 *	fmt		- String format
 *
 * Returns: Substituted string on success, NULL on failure
 */
char *
lvmap_var_fmt(cvec *head, char *fmt)
{
  int     len;
  int     vlen;
  int     slen;
  char   *ptr;
  char   *vnam;
  char   *vfmt;
  char   *str;
  char   *sptr;
  char   *vptr;
  cg_var *cv;

  if (!fmt || !strlen(fmt)) 
    return NULL;
  
  str = sptr = NULL;
  slen = 0;
  /* Loop twice, first round, calculate required length, 2nd 
   * round, allocate mem and create string  */
  while (str == NULL) {
    
    if (slen) {  /* 2nd round we have a length, allocate mem */
      if ((str = (char *)malloc (slen+1)) == NULL)
	goto catch;
      memset (str, '\0', slen+1);
      sptr = str;
    }
    
    len = 0;
    ptr = fmt;
    while (*ptr) {
      
      /* variable ? */
      if (*ptr == '$' && *(ptr+1) && *(ptr+1) != '$' && 
	  (ptr == fmt || (ptr-1 >= fmt && *(ptr-1) != '$'))) {
	
	vnam = ++ptr;
	/* move forward to last char of variable name */
	while (*ptr && (isalnum(*ptr) || *ptr == '_'))
	  ptr++;
	
	/* Copy variable name */
	vlen = ptr-vnam;
	if ((vnam = chunkdup (vnam, vlen+1, __FUNCTION__)) == NULL)
	  goto catch;
	vnam[vlen] = '\0';
	
	/* Do we have a variable format */
	if (*ptr == '{') {
	  vfmt = ++ptr;
	  /* move forward to end bracket */
	  while (*ptr && *ptr != '}')
	    ptr++;
	  vlen =  ptr - vfmt;
	  if ((vfmt = chunkdup (vfmt, vlen+1, __FUNCTION__)) == NULL)
	    goto catch;
	  vfmt[vlen] = '\0';	
	}
	else {
	  if ((vfmt = chunkdup ("$$", strlen("$$")+1, __FUNCTION__)) == NULL)
	    goto catch;
	  ptr--;
	}
	
	if (0)
	  fprintf (stderr, "%s: vnam=\"%s\" , vfmt=\"%s\"\n", 
		   __FUNCTION__, vnam, vfmt);

	/* Print/Calculate varible format string if variable exist */
	if (cvec_find (head, vnam)) {
	  vptr = vfmt;
	  while (*vptr) {
	    
	    if (*vptr == '$' && *(vptr+1) == '$') {
	      if ((cv = cvec_find (head, vnam))) {
		  len += cv2str (cv, sptr, (sptr ? slen+1-len : 0));
		  if (sptr)
		      sptr += cv2str(cv, NULL,0);
		  cv_free(cv);
	      }
	      vptr++;
	    }
	    else {
	      len++;
	      if (sptr)
		*sptr++ = *vptr;
	    }

	    vptr++;
	  }
	}
	
	/* Clean-up */
	unchunk(vnam);
	unchunk(vfmt); 
	
      } else if (*ptr == '$' && *(ptr+1) && *(ptr+1) == '$') {
	/* Do nothing, just skip character */

      } else { /* '$' */
	len++;
	if (sptr)
	  *sptr++ = *ptr;
      }  
      
      ptr++;
      
    } /* while */
    
    slen = len;
  }  

  unchunk_group(__FUNCTION__);
  return str;

 catch:
  unchunk_group(__FUNCTION__);
  if (str)
    free (str);
    
  return NULL;
}


/*
 * Parse 'str' and populate a given 'cgv'. Return a pointer to the
 * given string after the variable format.
 */
static char *
lvmap_eat_var(char *str, cg_var *cgv)
{
    char *ptr;
    char *start;
    char *sval = NULL;
    char *ret = NULL;

    ptr = str;

    /* Eat leading '%' */
    if (*ptr++ != '%')
	goto err;
    
    /* Check type */
    cv_type_set(cgv, lv_arg_2_cv_type (*ptr++));
    if (cv_type_get(cgv) == CGV_ERR)
	goto err;
    cv_name_set(cgv, NULL);

    /* We not expect a start bracket */
    if (*ptr++ != '{')
	goto err;

    start = ptr;
    /* Move ahead to closing bracket */
    while (*ptr && *ptr != '}')
	ptr++;

    /* Did we get the end bracket? */
    if (*ptr != '}')
	goto err;
    
    /* Make copy of value string */
    if (ptr-start > 0)
	sval = strndup(start, (ptr-start));
    else
	sval = strdup("");
    ptr++;

    /* Parse variable */
    if (cv_parse (sval, cgv) < 0)
	goto err;

    ret = ptr;
    /* Fall through */
err:
    if(sval)
	free (sval); 
    return ret;
}


/*
 * Parse variable format string, in cmp?if:else format.
 * Example: "$${%s{in}?%s{import}:%s{export}}"
 * Return result cgv to replace original variable.
 */
static cg_var *
lvmap_eat_varfmt(cg_var *cgv, char **str)
{
    int stack;
    char *ptr;
    char *fmt;
    char *tmp;
    cg_var *compval = NULL;
    cg_var *ifval = NULL;
    cg_var *elseval = NULL;
    cg_var *ret = NULL;

    ptr = *str;

    /* Find the end of the format statement */
    stack = 1;
    while(*ptr) {
	if (*ptr == '{') stack++; 
	else if (*ptr == '}') stack--;
	if (stack == 0)
	    break;
	ptr++;
    }
    
    tmp = *str;
    /* Move pointer forward for caller */
    *str = ptr+1;
    if ((fmt = strndup(tmp, ptr-tmp)) == NULL)
	goto err;
    if ((compval = cv_new(CGV_STRING)) == NULL ||
	(ifval = cv_new(CGV_STRING)) == NULL ||
	(elseval = cv_new(CGV_STRING)) == NULL)
	goto err;

    if ((tmp = lvmap_eat_var(fmt, compval)) == NULL || *tmp++ != '?')
	goto err;
    if ((tmp = lvmap_eat_var(tmp, ifval)) == NULL || *tmp++ != ':')
	goto err;
    if ((tmp = lvmap_eat_var(tmp, elseval)) == NULL)
	goto err;

    if(cv_cmp(cgv, compval) == 0)
	ret = ifval;
    else
	ret = elseval;
    
    err:
	if(fmt) free(fmt);
	if(compval) { cv_free(compval); }
	if(ifval && ifval != ret) { cv_free(ifval);  }
	if(elseval && elseval != ret) { cv_free(elseval); }
	
	return ret;
}

/*
 * Generate string based on variable list and a string format.
 *
 * Variable substitutions is specified in format as $varname. It is
 * a also possible to add conditional format for a variable by appending
 * it to within curly brackets, i.e. $varname{some text $$ and again $$}.
 * The value for $varname will substitute $$. If $varname does not
 * exist, nothing will be generated. The actual variable value does not
 * have to be included in the variable format. The existance of the 
 * variable can simply a condition for some text, i.e. $varname{some text} 
 *
 * Arguments:
 *	head	  	- Variable head structure
 *	fmt		- String format
 *
 * Returns: Substituted string on success, NULL on failure
 */
char *
lvmap_fmt (char *dbname, char *fmt, char *defkey)
{
    int len;
    int vlen;
    int slen;
    int stack;
    char *ptr;
    char *vnam;
    char *vfmt;
    char *str;
    char *sptr;
    char *vptr;
    char *key;
    char *tmp;
    cg_var *cgv;
    cg_var *cval;

    if (!fmt || !strlen(fmt)) 
	return NULL;
  
    str = sptr = NULL;
    slen = 0;
    /* Loop twice, first round, calculate required length, 2nd 
     * round, allocate mem and create string  */
    while (str == NULL) {
    
	if (slen) {  /* 2nd round we have a length, allocate mem */
	    if ((str = (char *)malloc (slen+1)) == NULL)
		goto catch;
	    memset (str, '\0', slen+1);
	    sptr = str;
	}
    
	len = 0;
	ptr = fmt;
	while (*ptr) {
	    
	    vnam = key = NULL;

	    /* variable ? */
	    if (*ptr == '$' && *(ptr+1) && *(ptr+1) != '$' && 
		(ptr == fmt || (ptr-1 >= fmt && *(ptr-1) != '$'))) {
	
		vnam = ++ptr;
		/* move forward to last char of variable name */
		while (*ptr && (isalnum(*ptr) || *ptr=='.'|| *ptr == ':' || *ptr == '_'))
		    ptr++;
	
		/* Copy variable name */
		vlen = ptr-vnam;
		if ((vnam = chunkdup (vnam, vlen+1, __FUNCTION__)) == NULL)
		    goto catch;
		vnam[vlen] = '\0';
	
		/* Extract db-key if required */
		if((tmp = strrchr(vnam, ':'))) {
		    *tmp = '\0';
		    key = vnam;
		    vnam = chunk_sprintf(__FUNCTION__, "%s", tmp+1);
		} else {
		    key = chunk_sprintf(__FUNCTION__, "%s", defkey);
		}
	    
		/* Do we have a variable format */
		if (*ptr == '{') {
		    vfmt = ++ptr;
		    /* move forward to end bracket */
		    stack = 1;
		    while (*ptr) {
			if(*ptr == '{') stack++;
			if(*ptr == '}') stack--;
			if(stack == 0) break;
			ptr++;
		    }
		    vlen =  ptr - vfmt;
		    if ((vfmt = chunkdup (vfmt, vlen+1, __FUNCTION__)) == NULL)
			goto catch;
		    vfmt[vlen] = '\0';
		}
		else {
		    if ((vfmt = chunkdup ("$$", strlen("$$")+1, __FUNCTION__)) == NULL)
			goto catch;
		    ptr--;
		}
	
		if (0)
		    fprintf (stderr, "%s: vnam=\"%s\" , vfmt=\"%s\"\n", 
			     __FUNCTION__, vnam, vfmt);

		/* Print/Calculate varible format string if variable exist */
		if ((cgv = dbvar2cv(dbname, key, vnam))) {
		    vptr = vfmt;
		    while (*vptr) {
		
			if (*vptr == '$' && *(vptr+1) == '$') {
			    
			    vptr += 2;
			    /* Do we have an if-else clause? */
			    if (*vptr == '{') {
				vptr++;
				if((cval = lvmap_eat_varfmt(cgv, &vptr))!=NULL){
				    cv_free(cgv);
				    cgv = cval;
				}
			    }
			    len += cv2str (cgv, sptr, (sptr ? slen+1-len : 0));
			    if (sptr)
				sptr += cv2str(cgv,NULL,0);
			    cv_free(cgv);
			    vptr--;
			}
			else {
			    len++;
			    if (sptr)
				*sptr++ = *vptr;
			}
			vptr++;
		    }
		}
		/* Clean-up */
		unchunk(vnam);
		unchunk(vfmt); 
	
	    } else if (*ptr == '$' && *(ptr+1) && *(ptr+1) == '$') {
		/* Do nothing, just skip character */

	    } else { /* '$' */
		len++;
		if (sptr)
		    *sptr++ = *ptr;
	    }  
      
	    ptr++;
      
	} /* while */
    
	if (len == 0) /* Format resulted in empty string */
	    goto catch;
	slen = len;
    }  

    unchunk_group(__FUNCTION__);
    return str;

catch:
    unchunk_group(__FUNCTION__);
    if (str)
	free (str);
    
    return NULL;
}
