/*
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 * Yang functions
  */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <ctype.h>
#define __USE_GNU /* strverscmp */
#include <string.h>
#include <arpa/inet.h>
#include <regex.h>
#include <syslog.h>
#include <assert.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include "clicon_log.h"
#include "clicon_err.h"
#include "clicon_string.h"
#include "clicon_queue.h"
#include "clicon_hash.h"
#include "clicon_handle.h"
#include "clicon_dbspec_key.h"
#include "clicon_yang.h"
#include "clicon_hash.h"
#include "clicon_lvalue.h"
#include "clicon_lvmap.h"
#include "clicon_chunk.h"
#include "clicon_options.h"
#include "clicon_dbutil.h"
#include "clicon_yang.h"
#include "clicon_yang_type.h"

/* 
 * Local types and variables
 */
/* Struct used to map between int and strings. Used  for:
 * - mapping yang types/typedefs (strings) and cligen types (ints). 
 * - mapping yang keywords (strings) and enum (clicon)
 * (same struct in clicon_yang.c)
 */
struct map_str2int{
    char         *ms_str; /* string as in 4.2.4 in RFC 6020 */
    int           ms_int;
};

/* Mapping between yang types <--> cligen types
   Note, first match used wne translating from cv to yang --> order is significant */
static const struct map_str2int ytmap[] = {
    {"int32",       CGV_INT32},  /* NOTE, first matchis significant, dont move */
    {"binary",      CGV_INT32}, /* XXX not really int */
    {"bits",        CGV_INT32}, /* XXX not really int */
    {"boolean",     CGV_BOOL},
    {"decimal64",   CGV_DEC64},  
    {"empty",       CGV_INT32},  /* XXX not really int */
    {"enumeration", CGV_INT32},  /* XXX not really int */
    {"identityref", CGV_INT32},  /* XXX not really int */
    {"instance-identifier", CGV_INT}, /* XXX not really int */
    {"int8",        CGV_INT8},  
    {"int16",       CGV_INT16},  
    {"int64",       CGV_INT64},
    {"leafref",     CGV_INT32},  /* XXX not really int */
    {"string",      CGV_STRING},
    {"uint8",       CGV_UINT8}, 
    {"uint16",      CGV_UINT16},
    {"uint32",      CGV_UINT32},
    {"uint64",      CGV_UINT64},
    {"union",       CGV_INT32},  /* XXX not really int */
    {NULL, -1}
};

/* return 1 if built-in, 0 if not */
static int
yang_builtin(char *type)
{
    const struct map_str2int *yt;

    /* built-in types */
    for (yt = &ytmap[0]; yt->ms_str; yt++)
	if (strcmp(yt->ms_str, type) == 0)
	    return 1;
    return 0;
}

/*! Translate from a yang type to a cligen variable type
 *
 * Currently many built-in types from RFC6020 and some RFC6991 types.
 * But not all, neither built-in nor 6991.
 * Also, there is no support for derived types, eg yang typedefs.
 * See 4.2.4 in RFC6020
 * Return 0 if no match but set cv_type to CGV_ERR
 */
int
yang2cv_type(char *ytype, enum cv_type *cv_type)
{
    const struct map_str2int *yt;

    *cv_type = CGV_ERR;
    /* built-in types */
    for (yt = &ytmap[0]; yt->ms_str; yt++)
	if (strcmp(yt->ms_str, ytype) == 0){
	    *cv_type = yt->ms_int;
	    return 0;
	}
    /* special derived types */
    if (strcmp("ipv4-address", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV4ADDR;
	return 0;
    }
    if (strcmp("ipv6-address", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV6ADDR;
	return 0;
    }
    if (strcmp("ipv4-prefix", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV4PFX;
	return 0;
    }
    if (strcmp("ipv6-prefix", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV6PFX;
	return 0;
    }
    if (strcmp("date-and-time", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_TIME;
	return 0;
    }
    if (strcmp("mac-address", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_MACADDR;
	return 0;
    }
    if (strcmp("uuid", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_UUID;
	return 0;
    }
    return 0;
}

/*! Translate from a cligen variable type to a yang type
 */
char *
cv2yang_type(enum cv_type cv_type)
{
    const struct map_str2int  *yt;
    char                *ytype;

    ytype = "empty";
    /* built-in types */
    for (yt = &ytmap[0]; yt->ms_str; yt++)
	if (yt->ms_int == cv_type)
	    return yt->ms_str;

    /* special derived types */
    if (cv_type == CGV_IPV4ADDR) /* RFC6991 */
	return "ipv4_address";

    if (cv_type == CGV_IPV6ADDR) /* RFC6991 */
	return "ipv6_address";

    if (cv_type == CGV_IPV4PFX) /* RFC6991 */
	return "ipv4_prefix";

    if (cv_type == CGV_IPV6PFX) /* RFC6991 */
	return "ipv6_prefix";

    if (cv_type == CGV_TIME) /* RFC6991 */
	return "date-and-time";

    if (cv_type == CGV_MACADDR) /* RFC6991 */
	return "mac-address";

    if (cv_type == CGV_UUID) /* RFC6991 */
	return "uuid";

    return ytype;
}

/*! translate from yang type -> cligen type, after yang resolve has been made.
 * handle case where yang resolve did not succedd (rtype=NULL) and then try
 * to find special cligen types such as ipv4addr.
 * not true yang types
 */
int
clicon_type2cv(char *type, char *rtype, enum cv_type *cvtype)
{
    int retval = -1;

    *cvtype = CGV_ERR;
    if (rtype == NULL){
	/* Not resolved, but we can use special cligen types, eg ipv4addr */
	yang2cv_type(type, cvtype);
	if (*cvtype == CGV_ERR){
	    clicon_err(OE_DB, 0, "%s: \"%s\": type not resolved", __FUNCTION__, type);
	    goto done;
	}
    }
    else{
	yang2cv_type(rtype, cvtype);
	if (*cvtype == CGV_ERR){
	    clicon_err(OE_DB, 0, "%s: \"%s\" type not translated", __FUNCTION__, rtype);
	    goto done;
	}
    }
    retval = 0;
  done:
    return retval;
}


/*! Validate cligen variable cv using yang statement as spec
 *
 * @param [in]  cv      A cligen variable to validate. This is a correctly parsed cv.
 * @param [in]  ys      A yang statement, must be leaf of leaf-list.
 * @param [out] reason  If given, and if return value is 0, contains a malloced string
 *                      describing the reason why the validation failed. Must be freed.
 * @retval -1  Error (fatal), with errno set to indicate error
 * @retval 0   Validation not OK, malloced reason is returned. Free reason with free()
 * @retval 1   Validation OK
 */
int
ys_cv_validate(cg_var *cv, yang_stmt *ys, char **reason)
{
    int             retval = 1; /* OK */
    cg_var         *ycv;        /* cv of yang-statement */  
    int64_t         i = 0;
    uint64_t        u = 0;
    char           *str;
    int             options;
    int64_t         range_min; 
    int64_t         range_max; 
    char           *pattern;
    int             retval2;
    enum cv_type    cvtype;
    char           *type;  /* orig type */
    char           *rtype; /* resolved type */
    uint8_t         fraction; 

    if (ys->ys_keyword != Y_LEAF && ys->ys_keyword != Y_LEAF_LIST)
	return 0;
    ycv = ys->ys_cv;
    if (yang_type_get(ys, &type, &rtype, &options, &range_min, &range_max, &pattern,
	    &fraction) < 0)
	goto err;
    if (clicon_type2cv(type, rtype, &cvtype) < 0)
	goto err;
    if (cv_type_get(ycv) != cvtype){
	clicon_err(OE_DB, 0, "%s: Type mismatch %d != %d", 
		   __FUNCTION__, cvtype, cv_type_get(ycv));
	goto err;
    }
    switch (cvtype){
    case CGV_INT8:
	i = cv_int8_get(cv);
	if ((options & YANG_OPTIONS_RANGE) != 0){
	    if (i < range_min || i > range_max) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %ld", i);
		retval = 0;
	    }
	}
	break;
    case CGV_INT16:
	i = cv_int16_get(cv);
	if ((options & YANG_OPTIONS_RANGE) != 0){
	    if (i < range_min || i > range_max) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %ld", i);
		retval = 0;
	    }
	}
	break;
    case CGV_INT32:
	i = cv_int32_get(cv);
	if ((options & YANG_OPTIONS_RANGE) != 0){
	    if (i < range_min || i > range_max) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %ld", i);
		retval = 0;
	    }
	}
	break;
    case CGV_INT64:
	i = cv_int64_get(cv);
	if ((options & YANG_OPTIONS_RANGE) != 0){
	    if (i < range_min || i > range_max) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %ld", i);
		retval = 0;
	    }
	}
	break;
    case CGV_UINT8:
	u = cv_uint8_get(cv);
	if ((options & YANG_OPTIONS_RANGE) != 0){
	    if (u < range_min || u > range_max) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %lu", u);
		retval = 0;
	    }
	}
	break;
    case CGV_UINT16:
	u = cv_uint16_get(cv);
	if ((options & YANG_OPTIONS_RANGE) != 0){
	    if (u < range_min || u > range_max) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %lu", u);
		retval = 0;
	    }
	}
	break;
    case CGV_UINT32:
	u = cv_uint32_get(cv);
	if ((options & YANG_OPTIONS_RANGE) != 0){
	    if (u < range_min || u > range_max) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %lu", u);
		retval = 0;
	    }
	}
	break;
    case CGV_UINT64:
	u = cv_uint64_get(cv);
	if ((options & YANG_OPTIONS_RANGE) != 0){
	    if (u < range_min || u > range_max) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %lu", u);
		retval = 0;
	    }
	}
	break;
    case CGV_DEC64:
	/* XXX: fraction_digits ? */
	break;
    case CGV_STRING:
	str = cv_string_get(cv);
	i = strlen(str);
	if ((options & YANG_OPTIONS_LENGTH) != 0){
	    if (i < range_min || i > range_max) {
		if (reason)
		    *reason = cligen_reason("string length out of range: %i", i);
		retval = 0;
	    }
	}
	if ((options & YANG_OPTIONS_PATTERN) != 0){
	    if ((retval2 = match_regexp(str, pattern)) < 0){
		clicon_err(OE_DB, 0, "match_regexp: %s", pattern);
		return -1;
	    }
	    if (retval2 == 0){
		if (reason)
		    *reason = cligen_reason("regexp match fail: \"%s\" does not match %s",
					    str, pattern);
		retval = 0;
	    }
	}
	break;
    case CGV_ERR:
    case CGV_VOID:
	retval = 0;
	if (reason)
	    *reason = cligen_reason("Invalid cv");
	retval = 0;
	break;
    case CGV_BOOL:
    case CGV_INTERFACE:
    case CGV_REST:
    case CGV_IPV4ADDR: 
    case CGV_IPV6ADDR: 
    case CGV_IPV4PFX: 
    case CGV_IPV6PFX: 
    case CGV_MACADDR:
    case CGV_URL: 
    case CGV_UUID: 
    case CGV_TIME: 
	break;
    }

    if (reason && *reason)
	assert(retval == 0);
    return retval;
  err:
    return -1;
}

/*
 * a typedef can be under module, submodule, container, list, grouping, rpc, 
 * input, output, notification
 */
static inline int
ys_typedef(yang_stmt *ys)
{
    return ys->ys_keyword == Y_MODULE || ys->ys_keyword == Y_SUBMODULE ||
	ys->ys_keyword == Y_CONTAINER || ys->ys_keyword == Y_LIST;
}

/* find next ys up which can contain a typedef */
static yang_stmt *
ys_up(yang_stmt *ys)
{
    yang_node *yn;

    while (ys != NULL && !ys_typedef(ys)){
	yn = ys->ys_parent;
	/* Some extra stuff to ensure ys is a stmt */
	if (yn && yn->yn_keyword == Y_SPEC)
	    yn = NULL;
	ys = (yang_stmt*)yn;
    }
    /* Here it is either NULL or is a typedef-kind yang-stmt */
    return (yang_stmt*)ys;
}

/* find top of tree: module or sub-module */
static yang_stmt *
ys_top(yang_stmt *ys)
{
    yang_node *yn;

    while (ys != NULL && ys->ys_keyword != Y_MODULE && ys->ys_keyword != Y_SUBMODULE){
	yn = ys->ys_parent;
	/* Some extra stuff to ensure ys is a stmt */
	if (yn && yn->yn_keyword == Y_SPEC)
	    yn = NULL;
	ys = (yang_stmt*)yn;
    }
    /* Here it is either NULL or is a typedef-kind yang-stmt */
    return (yang_stmt*)ys;
}

/* find top of tree: specification */
static yang_spec *
ys_spec(yang_stmt *ys)
{
    yang_node *yn;

    while (ys != NULL && ys->ys_keyword != Y_SPEC){
	yn = ys->ys_parent;
	ys = (yang_stmt*)yn;
    }
    /* Here it is either NULL or is a typedef-kind yang-stmt */
    return (yang_spec*)ys;
}

static yang_stmt *
ys_prefix2import(yang_stmt *ys, char *prefix)
{
    yang_stmt *ytop;
    yang_stmt *yimport = NULL;
    yang_stmt *yprefix;

    ytop      = ys_top(ys);
    while ((yimport = yn_each((yang_node*)ytop, yimport)) != NULL) {
	if (yimport->ys_keyword != Y_IMPORT)
	    continue;
	if ((yprefix = yang_find((yang_node*)yimport, Y_PREFIX, NULL)) != NULL &&
	    strcmp(yprefix->ys_argument, prefix) == 0)
	    return yimport;
    }
    return NULL;
}

/*
 * Extract id from type argument. two cases:
 * argument is prefix:id, 
 * argument is id,        
 * Just return string from id
 */
static char*
ytype_id(yang_stmt *ys)
{
    char   *id;
    
    if ((id = strchr(ys->ys_argument, ':')) == NULL)
	id = ys->ys_argument;
    else
	id++;
    return id;
}

/*
 * Extract prefix from type argument. two cases:
 * argument is prefix:id, 
 * argument is id,        
 * return either NULL or a new prefix string that needs to be freed by caller.
 */
static char*
ytype_prefix(yang_stmt *ys)
{
    char   *id;
    char   *prefix = NULL;
    
    if ((id = strchr(ys->ys_argument, ':')) != NULL){
	prefix = strdup(ys->ys_argument);
	prefix[id-ys->ys_argument] = '\0';
    }
    return prefix;
}


/*
 */
static int
resolve_restrictions(yang_stmt   *yrange,
		     yang_stmt   *ypattern,
		     yang_stmt   *yfraction,
		     int         *options, 
		     int64_t     *min, 
		     int64_t     *max, 
		     char       **pattern,
		     uint8_t     *fraction)
{
    if (options && min && max && yrange != NULL){
	*options  |= YANG_OPTIONS_LENGTH;
	*min       = yrange->ys_range_min;
	*max       = yrange->ys_range_max;
    }
    if (options && pattern && ypattern != NULL){
	*options  |= YANG_OPTIONS_PATTERN;
	*pattern   = ypattern->ys_argument;
    }
    if (options && fraction && yfraction != NULL){
	*options  |= YANG_OPTIONS_FRACTION_DIGITS;
	*fraction  = cv_uint8_get(yfraction->ys_cv);
    }
    return 0;
}

/*! Recursively resolve a yang type to built-in type with optional restrictions
 * @param [in]  ys       yang-stmt from where the current search is based
 * @param [in]  ytype    yang-stmt object containing currently resolving type
 * @param [out] rtype    resolved type. return built-in type or NULL. mandatory
 * @param [out] options  pointer to flags field of optional values. optional
 * @param [out] min      pointer to min range or length. optional
 * @param [out] max      pointer to max range or length. optional
 * @param [out] pattern  pointer to static string of yang string pattern. optional
 * @param [out] fraction for decimal64, how many digits after period
 * @retval      0        OK. Note rtype may still be NULL.
 * @retval     -1        Error, clicon_err handles errors
 * Note that the static output strings (type, pattern) should be copied if used asap.
 * Note also that for all pointer arguments, if NULL is given, no value is assigned.
 */
int 
yang_type_resolve(yang_stmt   *ys, 
		  yang_stmt   *ytype, 
		  char       **rtype, 
		  int         *options, 
		  int64_t     *min, 
		  int64_t     *max, 
		  char       **pattern,
		  uint8_t     *fraction)
{
    yang_stmt   *rytypedef = NULL; /* Resolved typedef of ytype */
    yang_stmt   *rytype;           /* Resolved type of ytype */
    yang_stmt   *yrange;
    yang_stmt   *ypattern;
    yang_stmt   *yfraction;
    yang_stmt   *yimport;
    char        *type;
    char        *prefix = NULL;
    int          retval = -1;
    yang_node   *yn;
    yang_spec   *yspec;
    yang_stmt   *ymodule;

    if (options)
	*options = 0x0;
    *rtype    = NULL; /* Initialization of resolved type that may not be necessary */
    type      = ytype_id(ytype);     /* This is the type to resolve */
    prefix    = ytype_prefix(ytype); /* And this its prefix */

    yrange    = yang_find((yang_node*)ytype, Y_RANGE, NULL);
    ypattern  = yang_find((yang_node*)ytype, Y_PATTERN, NULL);
    yfraction = yang_find((yang_node*)ytype, Y_FRACTION_DIGITS, NULL);
    /* Check if type is basic type. If so, return that */
    if (prefix == NULL && yang_builtin(type)){
	*rtype = type;
	resolve_restrictions(yrange, ypattern, yfraction, options, min, max, pattern, fraction);
	goto ok;
    }
    /* Not basic type. Now check if prefix which means we look in other module */
    if (prefix){ /* Go to top and find import that matches */
	if ((yimport = ys_prefix2import(ys, prefix)) == NULL){
	    clicon_err(OE_DB, 0, "Prefix %s not defined not found", prefix);
	    goto done;
	}
	yspec = ys_spec(ys);
	if ((ymodule = yang_find((yang_node*)yspec, Y_MODULE, yimport->ys_argument)) == NULL)
	    goto ok; /* unresolved */
	if ((rytypedef = yang_find((yang_node*)ymodule, Y_TYPEDEF, type)) == NULL)
	    goto ok; /* unresolved */
    }
    else
	while (1){
	    /* Check if ys may have typedefs otherwise find one that can */
	    if ((ys = ys_up(ys)) == NULL){ /* If reach top */
		*rtype = NULL;
		break;
	    }
	    /* Here find typedef */
	    if ((rytypedef = yang_find((yang_node*)ys, Y_TYPEDEF, type)) != NULL)
		break;
	    /* Did not find a matching typedef there, proceed to next level */
	    yn = ys->ys_parent;
	    if (yn && yn->yn_keyword == Y_SPEC)
		yn = NULL;
	    ys = (yang_stmt*)yn;
	}
    if (rytypedef != NULL){     /* We have found a typedef */
	/* Find associated type statement */
	if ((rytype = yang_find((yang_node*)rytypedef, Y_TYPE, NULL)) == NULL){
	    clicon_err(OE_DB, 0, "%s: mandatory type object is not found", __FUNCTION__);
	    goto done;
	}
	/* recursively resolve this new type */
	if (yang_type_resolve(ys, rytype, rtype, 
			      options, min, max, pattern, fraction) < 0)
	    goto done;
	/* overwrites the resolved if any */
	resolve_restrictions(yrange, ypattern, yfraction, options, min, max, pattern, fraction);
    }
  ok:
    retval = 0;
  done:
    if (prefix)
	free(prefix);
    return retval;
}

/*! Get type information about a leaf/leaf-list yang-statement
 *
 * @code
 *   char         *rtype;
 *   int           options;
 *   int64_t       min, max;
 *   char         *pattern;
 *   uint8_t       fraction;
 *
 *   if (yang_type_get(ys, &type, &rtype, &options, &min, &max, &pattern, &fraction) < 0)
 *      goto err;
 *   if (rtype == NULL) # unresolved
 *      goto err;
 *   if (options & YANG_OPTIONS_LENGTH != 0)
 *      printf("%d..%d\n", min , max);
 *   if (options & YANG_OPTIONS_PATTERN != 0)
 *      printf("regexp: %s\n", pattern);
 * @endcode
 * @param [in]  ys       yang-stmt, leaf or leaf-list
 * @param [out] otype    original type may be derived or built-in
 * @param [out] rtype    resolved type is built-in
 * @param [out] options  pointer to flags field of optional values
 * @param [out] min      pointer to min range or length. optional
 * @param [out] max      pointer to max range or length. optional
 * @param [out] pattern  pointer to static string of yang string pattern. optional
 * @param [out] fraction for decimal64, how many digits after period
 * @retval      0        OK, but note that rtype==NULL means not resolved.
 * @retval     -1        Error, clicon_err handles errors
 * Note that the static output strings (type, pattern) should be copied if used asap.
 * Note also that for all pointer arguments, if NULL is given, no value is assigned.
 * See also yang_type_resolve(). This function is really just a frontend to that.
 */
int 
yang_type_get(yang_stmt    *ys, 
	      char        **origtype, 
	      char        **rtype, 
	      int          *options, 
	      int64_t      *min, 
	      int64_t      *max, 
	      char        **pattern,
	      uint8_t      *fraction
    )
{
    int retval = -1;
    yang_stmt    *ytype;        /* type */
    char         *type;

    if (options)
	*options = 0x0;
    /* Find mandatory type */
    if ((ytype = yang_find((yang_node*)ys, Y_TYPE, NULL)) == NULL){
	clicon_err(OE_DB, 0, "%s: mandatory type object is not found", __FUNCTION__);
	goto done;
    }
    type = ytype_id(ytype);
    if (origtype)
	*origtype = type;
    if (yang_type_resolve(ys, ytype, rtype, options, min, max, pattern, fraction) < 0)
	goto done;
    clicon_debug(1, "%s: %s %s->%s\n", __FUNCTION__, ys->ys_argument, type, 
		 rtype?*rtype:"null");
    retval = 0;
  done:
    return retval;
}
