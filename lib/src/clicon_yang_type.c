/*
 *  CVS Version: $Id: clicon_spec.c,v 1.29 2013/09/19 16:03:40 olof Exp $
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 * Yang functions
  */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <ctype.h>
#define __USE_GNU /* strverscmp */
#include <string.h>
#include <arpa/inet.h>
#include <regex.h>
#include <syslog.h>
#include <assert.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include "clicon_log.h"
#include "clicon_err.h"
#include "clicon_string.h"
#include "clicon_queue.h"
#include "clicon_hash.h"
#include "clicon_handle.h"
#include "clicon_spec.h"
#ifdef USE_DBSPEC_PT
#include "clicon_dbspec_parsetree.h"
#endif /* USE_DBSPEC_PT */
#include "clicon_yang.h"
#include "clicon_hash.h"
#include "clicon_lvalue.h"
#include "clicon_lvmap.h"
#include "clicon_chunk.h"
#include "clicon_options.h"
#include "clicon_dbutil.h"
#ifdef USE_DBSPEC_PT
#include "clicon_dbspec.h"
#endif /* USE_DBSPEC_PT */
#include "clicon_yang.h"
#include "clicon_yang_type.h"

/* 
 * Local types and variables
 */
/* Struct used to map between int and strings. Used  for:
 * - mapping yang types/typedefs (strings) and cligen types (ints). 
 * - mapping yang keywords (strings) and enum (clicon)
 * (same struct in clicon_yang.c)
 */
struct map_str2int{
    char         *ms_str; /* string as in 4.2.4 in RFC 6020 */
    int           ms_int;
};

/* Mapping between yang types <--> cligen types
   Note, first match used wne translating from cv to yang --> order is significant */
static const struct map_str2int ytmap[] = {
    {"int32",       CGV_INT},
    {"binary",      CGV_INT}, /* XXX not really int */
    {"bits",        CGV_INT}, /* XXX not really int */
    {"boolean",     CGV_BOOL},
    {"decimal64",   CGV_INT},  /* XXX not really int */
    {"empty",       CGV_INT},  /* XXX not really int */
    {"enumeration", CGV_INT},  /* XXX not really int */
    {"identityref", CGV_INT},  /* XXX not really int */
    {"instance-identifier", CGV_INT}, /* XXX not really int */
    {"int8",        CGV_INT},  /* XXX not really int */
    {"int16",       CGV_INT},  /* XXX not really int */
    {"int64",       CGV_LONG},
    {"leafref",     CGV_INT},  /* XXX not really int */
    {"string",      CGV_STRING},
    {"uint8",       CGV_INT},  /* XXX not really int */
    {"uint16",      CGV_INT},  /* XXX not really int */
    {"uint32",      CGV_INT},  /* XXX not really int */
    {"uint64",      CGV_LONG}, /* XXX not really int */
    {"union",       CGV_INT},  /* XXX not really int */
    {NULL, -1}
};


/*! Translate from a yang type to a cligen variable type
 *
 * Currently many built-in types from RFC6020 and some RFC6991 types.
 * But not all, neither built-in nor 6991.
 * Also, there is no support for derived types, eg yang typedefs.
 * See 4.2.4 in RFC6020
 * Return 0 if no match but set cv_type to CGV_ERR
 */
int
yang2cv_type(char *ytype, enum cv_type *cv_type)
{
    const struct map_str2int *yt;

    *cv_type = CGV_ERR;
    /* built-in types */
    for (yt = &ytmap[0]; yt->ms_str; yt++)
	if (strcmp(yt->ms_str, ytype) == 0){
	    *cv_type = yt->ms_int;
	    return 0;
	}

    /* special derived types */
    if (strcmp("ipv4-address", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV4ADDR;
	return 0;
    }
    if (strcmp("ipv6-address", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV6ADDR;
	return 0;
    }
    if (strcmp("ipv4-prefix", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV4PFX;
	return 0;
    }
    if (strcmp("ipv6-prefix", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV6PFX;
	return 0;
    }
    if (strcmp("date-and-time", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_TIME;
	return 0;
    }
    if (strcmp("mac-address", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_MACADDR;
	return 0;
    }
    if (strcmp("uuid", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_UUID;
	return 0;
    }
    return 0;
}

/*! Translate from a cligen variable type to a yang type
 */
char *
cv2yang_type(enum cv_type cv_type)
{
    const struct map_str2int  *yt;
    char                *ytype;

    ytype = "empty";
    /* built-in types */
    for (yt = &ytmap[0]; yt->ms_str; yt++)
	if (yt->ms_int == cv_type)
	    return yt->ms_str;

    /* special derived types */
    if (cv_type == CGV_IPV4ADDR) /* RFC6991 */
	return "ipv4_address";

    if (cv_type == CGV_IPV6ADDR) /* RFC6991 */
	return "ipv6_address";

    if (cv_type == CGV_IPV4PFX) /* RFC6991 */
	return "ipv4_prefix";

    if (cv_type == CGV_IPV6PFX) /* RFC6991 */
	return "ipv6_prefix";

    if (cv_type == CGV_TIME) /* RFC6991 */
	return "date-and-time";

    if (cv_type == CGV_MACADDR) /* RFC6991 */
	return "mac-address";

    if (cv_type == CGV_UUID) /* RFC6991 */
	return "uuid";

    return ytype;
}

/*! Validate cligen variable cv using yang statement as spec
 *
 * @param [in]  cv      A cligen variable to validate. This is a correctly parsed cv.
 * @param [in]  ys      A yang statement, must be leaf of leaf-list.
 * @param [out] reason  If given, and if return value is 0, contains a malloced string
 *                      describing the reason why the validation failed. Must be freed.
 * @retval -1  Error (fatal), with errno set to indicate error
 * @retval 0   Validation not OK, malloced reason is returned. Free reason with free()
 * @retval 1   Validation OK
 */
int
ys_cv_validate(cg_var *cv, yang_stmt *ys, char **reason)
{
    int             retval = 1; /* OK */
    cg_var         *ycv;        /* cv of yang-statement */  
    long long       i = 0;
    char           *str;
    int             options;
    int64_t         range_min, range_max; 
    char           *pattern;
    int             retval2;
    enum cv_type    cvtype;

    if (ys->ys_keyword != Y_LEAF && ys->ys_keyword != Y_LEAF_LIST)
	return 0;
    ycv = ys->ys_cv;
    if (yang_type_get(ys, NULL, &cvtype, &options, &range_min, &range_max, &pattern) < 0)
	goto err;
    if (cv_type_get(ycv) != cvtype){
	clicon_err(OE_DB, 0, "%s: Type mismatch %d != %d", 
		   __FUNCTION__, cvtype, cv_type_get(ycv));
	goto err;
    }
    switch (cvtype){
    case CGV_INT:
	i = cv_int_get(cv);
    case CGV_LONG: /* fallthru */
	 /* Check range if specified */
	if (cv_type_get(ycv) == CGV_LONG)
	    i = cv_long_get(cv);
	if ((options & YANG_OPTIONS_RANGE) != 0){
	    if (i < range_min || i > range_max) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %i", i);
		retval = 0;
	    }
	}
	break;
    case CGV_STRING:
	str = cv_string_get(cv);
	i = strlen(str);
	if ((options & YANG_OPTIONS_LENGTH) != 0){
	    if (i < range_min || i > range_max) {
		if (reason)
		    *reason = cligen_reason("String length out of range: %i", i);
		retval = 0;
	    }
	}
	if ((options & YANG_OPTIONS_PATTERN) != 0){
	    if ((retval2 = match_regexp(str, pattern)) < 0){
		clicon_err(OE_DB, 0, "match_regexp: %s", pattern);
		return -1;
	    }
	    if (retval2 == 0){
		if (reason)
		    *reason = cligen_reason("regexp match fail: %s does not match %s",
					    str, pattern);
		retval = 0;
	    }
	}
	break;
    case CGV_ERR:
    case CGV_VOID:
	retval = 0;
	if (reason)
	    *reason = cligen_reason("Invalid cv");
	retval = 0;
	break;
    case CGV_BOOL:
    case CGV_INTERFACE:
    case CGV_REST:
    case CGV_IPV4ADDR: 
    case CGV_IPV6ADDR: 
    case CGV_IPV4PFX: 
    case CGV_IPV6PFX: 
    case CGV_MACADDR:
    case CGV_URL: 
    case CGV_UUID: 
    case CGV_TIME: 
	break;
    }

    if (reason && *reason)
	assert(retval == 0);
    return retval;
  err:
    return -1;
}



/*! Get  information about a leaf/leaf-list yang-statement
 *
 * @code
 *   char         *type;
 *   enum cv_type *cvtype;
 *   int           options;
 *   int64_t       min, max;
 *   char         *pattern;
 *
 *   if (yang_type_get(ys, &type, &cvtype, &options, &min, &max, &pattern) < 0)
 *      goto err;
 *   if (cvtype!=CGV_STRING)
 *      goto err;
 *   if (options & YANG_OPTIONS_LENGTH != 0)
 *      printf("%d..%d\n", min , max);
 *   if (options & YANG_OPTIONS_PATTERN != 0)
 *      printf("regexp: %s\n", pattern);
 * @endcode
 * @param [in]  ys       yang-stmt, leaf or leaf-list
 * @param [out] type     pointer to static string of yang base-type
 * @param [out] cvtype   pointer to cligen type
 * @param [out] options  pointer to flags field of optional values
 * @param [out] min      pointer to min range or length. optional
 * @param [out] max      pointer to max range or length. optional
 * @param [out] pattern  pointer to static string of yang string pattern. optional
 * @retval      0        OK
 * @retval     -1        Error, clicon_err handles errors
 * Note that the static output strings (type, pattern) should be copied if used asap.
 * Note also that for all pointer arguments, if NULL is given, no value is assigned.
 */
int 
yang_type_get(yang_stmt    *ys, 
	      char        **type, 
	      enum cv_type *cvtype, 
	      int          *options, 
	      int64_t      *min, 
	      int64_t      *max, 
	      char        **pattern)
{
    int retval = -1;
    yang_stmt    *yt;        /* type */
    yang_stmt    *yr = NULL; /* range */
    yang_stmt    *yp = NULL; /* pattern */

    if (options)
	*options = 0x0;
    if (ys->ys_keyword != Y_LEAF && ys->ys_keyword != Y_LEAF_LIST){
	clicon_err(OE_DB, 0, "%s: type is %s, expected leaf or leaf-list", 
		   __FUNCTION__, yang_key2str(ys->ys_keyword));
	goto done;
    }
    if ((yt = yang_find((yang_node*)ys, Y_TYPE, NULL)) != NULL){        
	yr =  yang_find((yang_node*)yt, Y_RANGE, NULL);
	yp =  yang_find((yang_node*)yt, Y_PATTERN, NULL);
    }
    if (yt){
	if (type)
	    *type   = yt->ys_argument;
#if 1
	if (cvtype)
	    yang2cv_type(yt->ys_argument, cvtype);
#endif
    }
#if 0 /* alternative to above but here we assume a CV has been created. This is actually done in
       ys_populate_leaf(), but then we cant call this function before (or in) that. */
    if (cvtype)
	*cvtype = cv_type_get(ys->ys_cv);
#endif

    if (options && min && max && yr != NULL){
	*options |= YANG_OPTIONS_LENGTH;
	*min      = yr->ys_range_min;
	*max      = yr->ys_range_max;
    }
    if (options && pattern && yp != NULL){
	*options |= YANG_OPTIONS_PATTERN;
	*pattern      = yp->ys_argument;
    }
    retval = 0;
  done:
    return retval;
}
