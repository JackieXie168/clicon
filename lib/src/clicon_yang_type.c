/*
 *  CVS Version: $Id: clicon_spec.c,v 1.29 2013/09/19 16:03:40 olof Exp $
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 * Yang functions
  */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <ctype.h>
#define __USE_GNU /* strverscmp */
#include <string.h>
#include <arpa/inet.h>
#include <regex.h>
#include <syslog.h>
#include <assert.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include "clicon_log.h"
#include "clicon_err.h"
#include "clicon_string.h"
#include "clicon_queue.h"
#include "clicon_hash.h"
#include "clicon_handle.h"
#include "clicon_spec.h"
#include "clicon_yang.h"
#include "clicon_hash.h"
#include "clicon_lvalue.h"
#include "clicon_lvmap.h"
#include "clicon_chunk.h"
#include "clicon_options.h"
#include "clicon_dbutil.h"
#include "clicon_yang.h"
#include "clicon_yang_type.h"

/* 
 * Local types and variables
 */
/* Struct used to map between int and strings. Used  for:
 * - mapping yang types/typedefs (strings) and cligen types (ints). 
 * - mapping yang keywords (strings) and enum (clicon)
 * (same struct in clicon_yang.c)
 */
struct map_str2int{
    char         *ms_str; /* string as in 4.2.4 in RFC 6020 */
    int           ms_int;
};

/* Mapping between yang types <--> cligen types
   Note, first match used wne translating from cv to yang --> order is significant */
static const struct map_str2int ytmap[] = {
    {"int32",       CGV_INT},
    {"binary",      CGV_INT}, /* XXX not really int */
    {"bits",        CGV_INT}, /* XXX not really int */
    {"boolean",     CGV_BOOL},
    {"decimal64",   CGV_INT},  /* XXX not really int */
    {"empty",       CGV_INT},  /* XXX not really int */
    {"enumeration", CGV_INT},  /* XXX not really int */
    {"identityref", CGV_INT},  /* XXX not really int */
    {"instance-identifier", CGV_INT}, /* XXX not really int */
    {"int8",        CGV_INT},  /* XXX not really int */
    {"int16",       CGV_INT},  /* XXX not really int */
    {"int64",       CGV_LONG},
    {"leafref",     CGV_INT},  /* XXX not really int */
    {"string",      CGV_STRING},
    {"uint8",       CGV_INT},  /* XXX not really int */
    {"uint16",      CGV_INT},  /* XXX not really int */
    {"uint32",      CGV_INT},  /* XXX not really int */
    {"uint64",      CGV_LONG}, /* XXX not really int */
    {"union",       CGV_INT},  /* XXX not really int */
    {NULL, -1}
};

/* return 1 if built-in, 0 if not */
static int
yang_builtin(char *type)
{
    const struct map_str2int *yt;

    /* built-in types */
    for (yt = &ytmap[0]; yt->ms_str; yt++)
	if (strcmp(yt->ms_str, type) == 0)
	    return 1;
    return 0;
}

/*! Translate from a yang type to a cligen variable type
 *
 * Currently many built-in types from RFC6020 and some RFC6991 types.
 * But not all, neither built-in nor 6991.
 * Also, there is no support for derived types, eg yang typedefs.
 * See 4.2.4 in RFC6020
 * Return 0 if no match but set cv_type to CGV_ERR
 */
int
yang2cv_type(char *ytype, enum cv_type *cv_type)
{
    const struct map_str2int *yt;

    *cv_type = CGV_ERR;
    /* built-in types */
    for (yt = &ytmap[0]; yt->ms_str; yt++)
	if (strcmp(yt->ms_str, ytype) == 0){
	    *cv_type = yt->ms_int;
	    return 0;
	}
    /* special derived types */
    if (strcmp("ipv4-address", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV4ADDR;
	return 0;
    }
    if (strcmp("ipv6-address", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV6ADDR;
	return 0;
    }
    if (strcmp("ipv4-prefix", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV4PFX;
	return 0;
    }
    if (strcmp("ipv6-prefix", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_IPV6PFX;
	return 0;
    }
    if (strcmp("date-and-time", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_TIME;
	return 0;
    }
    if (strcmp("mac-address", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_MACADDR;
	return 0;
    }
    if (strcmp("uuid", ytype) == 0){ /* RFC6991 */
	*cv_type = CGV_UUID;
	return 0;
    }
    return 0;
}

/*! Translate from a cligen variable type to a yang type
 */
char *
cv2yang_type(enum cv_type cv_type)
{
    const struct map_str2int  *yt;
    char                *ytype;

    ytype = "empty";
    /* built-in types */
    for (yt = &ytmap[0]; yt->ms_str; yt++)
	if (yt->ms_int == cv_type)
	    return yt->ms_str;

    /* special derived types */
    if (cv_type == CGV_IPV4ADDR) /* RFC6991 */
	return "ipv4_address";

    if (cv_type == CGV_IPV6ADDR) /* RFC6991 */
	return "ipv6_address";

    if (cv_type == CGV_IPV4PFX) /* RFC6991 */
	return "ipv4_prefix";

    if (cv_type == CGV_IPV6PFX) /* RFC6991 */
	return "ipv6_prefix";

    if (cv_type == CGV_TIME) /* RFC6991 */
	return "date-and-time";

    if (cv_type == CGV_MACADDR) /* RFC6991 */
	return "mac-address";

    if (cv_type == CGV_UUID) /* RFC6991 */
	return "uuid";

    return ytype;
}

/*! Validate cligen variable cv using yang statement as spec
 *
 * @param [in]  cv      A cligen variable to validate. This is a correctly parsed cv.
 * @param [in]  ys      A yang statement, must be leaf of leaf-list.
 * @param [out] reason  If given, and if return value is 0, contains a malloced string
 *                      describing the reason why the validation failed. Must be freed.
 * @retval -1  Error (fatal), with errno set to indicate error
 * @retval 0   Validation not OK, malloced reason is returned. Free reason with free()
 * @retval 1   Validation OK
 */
int
ys_cv_validate(cg_var *cv, yang_stmt *ys, char **reason)
{
    int             retval = 1; /* OK */
    cg_var         *ycv;        /* cv of yang-statement */  
    long long       i = 0;
    char           *str;
    int             options;
    int64_t         range_min, range_max; 
    char           *pattern;
    int             retval2;
    enum cv_type    cvtype;
    char         *type;  /* orig type */
    char         *rtype; /* resolved type */

    if (ys->ys_keyword != Y_LEAF && ys->ys_keyword != Y_LEAF_LIST)
	return 0;
    ycv = ys->ys_cv;
    if (yang_type_get(ys, &type, &rtype, &options, &range_min, &range_max, &pattern) < 0)
	goto err;
    if (rtype == NULL){
	clicon_err(OE_DB, 0, "%s: \"%s\": type not resolved", __FUNCTION__, type);
	goto err;
    }
    yang2cv_type(rtype, &cvtype);
    if (cvtype == CGV_ERR){
	clicon_err(OE_DB, 0, "%s: \"%s\" type not translated", __FUNCTION__, rtype);
	goto err;
    }
    if (cv_type_get(ycv) != cvtype){
	clicon_err(OE_DB, 0, "%s: Type mismatch %d != %d", 
		   __FUNCTION__, cvtype, cv_type_get(ycv));
	goto err;
    }
    switch (cvtype){
    case CGV_INT:
	i = cv_int_get(cv);
    case CGV_LONG: /* fallthru */
	 /* Check range if specified */
	if (cv_type_get(ycv) == CGV_LONG)
	    i = cv_long_get(cv);
	if ((options & YANG_OPTIONS_RANGE) != 0){
	    if (i < range_min || i > range_max) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %i", i);
		retval = 0;
	    }
	}
	break;
    case CGV_STRING:
	str = cv_string_get(cv);
	i = strlen(str);
	if ((options & YANG_OPTIONS_LENGTH) != 0){
	    if (i < range_min || i > range_max) {
		if (reason)
		    *reason = cligen_reason("string length out of range: %i", i);
		retval = 0;
	    }
	}
	if ((options & YANG_OPTIONS_PATTERN) != 0){
	    if ((retval2 = match_regexp(str, pattern)) < 0){
		clicon_err(OE_DB, 0, "match_regexp: %s", pattern);
		return -1;
	    }
	    if (retval2 == 0){
		if (reason)
		    *reason = cligen_reason("regexp match fail: \"%s\" does not match %s",
					    str, pattern);
		retval = 0;
	    }
	}
	break;
    case CGV_ERR:
    case CGV_VOID:
	retval = 0;
	if (reason)
	    *reason = cligen_reason("Invalid cv");
	retval = 0;
	break;
    case CGV_BOOL:
    case CGV_INTERFACE:
    case CGV_REST:
    case CGV_IPV4ADDR: 
    case CGV_IPV6ADDR: 
    case CGV_IPV4PFX: 
    case CGV_IPV6PFX: 
    case CGV_MACADDR:
    case CGV_URL: 
    case CGV_UUID: 
    case CGV_TIME: 
	break;
    }

    if (reason && *reason)
	assert(retval == 0);
    return retval;
  err:
    return -1;
}

/*
 * a typedef can be under module, submodule, container, list, grouping, rpc, 
 * input, output, notification
 */
static inline int
ys_typedef(yang_stmt *ys)
{
    return ys->ys_keyword == Y_MODULE || ys->ys_keyword == Y_SUBMODULE ||
	ys->ys_keyword == Y_CONTAINER || ys->ys_keyword == Y_LIST;
}

/* find next ys up which can contain a typedef */
static yang_stmt *
ys_up(yang_stmt *ys)
{
    yang_node *yn;

    while (ys != NULL && !ys_typedef(ys)){
	yn = ys->ys_parent;
	/* Some extra stuff to ensure ys is a stmt */
	if (yn && yn->yn_keyword == Y_SPEC)
	    yn = NULL;
	ys = (yang_stmt*)yn;
    }
    /* Here it is either NULL or is a typedef-kind yang-stmt */
    return (yang_stmt*)ys;
}

static int
resolve_restrictions(yang_stmt   *yrange,
		     yang_stmt   *ypattern,
		     int         *options, 
		     int64_t     *min, 
		     int64_t     *max, 
		     char       **pattern)
{
    if (options && min && max && yrange != NULL){
	*options |= YANG_OPTIONS_LENGTH;
	*min      = yrange->ys_range_min;
	*max      = yrange->ys_range_max;
    }
    if (options && pattern && ypattern != NULL){
	*options |= YANG_OPTIONS_PATTERN;
	*pattern      = ypattern->ys_argument;
    }
    return 0;
}

/*! Recursively resolve a yang type to built-in type with optional restrictions
 * @param [in]  ys       yang-stmt from where the current search is based
 * @param [in]  ytype    yang-stmt object containing currently resolving type
 * @param [out] rtype    resolved type. return built-in type or NULL. mandatory
 * @param [out] options  pointer to flags field of optional values. optional
 * @param [out] min      pointer to min range or length. optional
 * @param [out] max      pointer to max range or length. optional
 * @param [out] pattern  pointer to static string of yang string pattern. optional
 * @retval      0        OK. Note rtype may still be NULL.
 * @retval     -1        Error, clicon_err handles errors
 * Note that the static output strings (type, pattern) should be copied if used asap.
 * Note also that for all pointer arguments, if NULL is given, no value is assigned.
 */
int 
yang_type_resolve(yang_stmt   *ys, 
		  yang_stmt   *ytype, 
		  char       **rtype, 
		  int         *options, 
		  int64_t     *min, 
		  int64_t     *max, 
		  char       **pattern)
{
    yang_stmt   *rytypedef = NULL; /* Resolved typedef of ytype */
    yang_stmt   *rytype;          /* Resolved type of ytype */
    yang_stmt   *yrange;
    yang_stmt   *ypattern;
    char        *type;
    int          retval = -1;
    yang_node   *yn;

    if (options)
	*options = 0x0;
    *rtype   = NULL; /* Initialization of resolved type that may not be necessary */
    type     = ytype->ys_argument; /* This is the type to resolve */
    yrange   =  yang_find((yang_node*)ytype, Y_RANGE, NULL);
    ypattern =  yang_find((yang_node*)ytype, Y_PATTERN, NULL);
    /* The type is a basic type. Return that */
    if (yang_builtin(type)){
	*rtype = type;
	resolve_restrictions(yrange, ypattern, options, min, max, pattern);
	goto ok;
    }
    while (1){
	/* Check if ys may have typedefs otherwise find one that can */
	if ((ys = ys_up(ys)) == NULL){ /* If reach top */
	    *rtype = NULL;
	    break;
	}
	/* Here find typedef */
	if ((rytypedef = yang_find((yang_node*)ys, Y_TYPEDEF, type)) != NULL)
	    break;
	/* Did not find a matching typedef there, proceed to next level */
	yn = ys->ys_parent;
	if (yn && yn->yn_keyword == Y_SPEC)
	    yn = NULL;
	ys = (yang_stmt*)yn;
    }
    if (rytypedef != NULL){     /* We have found a typedef */
	/* Find associated type statement */
	if ((rytype = yang_find((yang_node*)rytypedef, Y_TYPE, NULL)) == NULL){
	    clicon_err(OE_DB, 0, "%s: mandatory type object is not found", __FUNCTION__);
	    goto done;
	}
	/* recursively resolve this new type */
	if (yang_type_resolve(ys, rytype, rtype, 
			      options, min, max, pattern) < 0)
	    goto done;
	/* overwrites the resolved if any */
	resolve_restrictions(yrange, ypattern, options, min, max, pattern);
    }
  ok:
    retval = 0;
  done:
    return retval;
}

/*! Get type information about a leaf/leaf-list yang-statement
 *
 * @code
 *   char         *rtype;
 *   int           options;
 *   int64_t       min, max;
 *   char         *pattern;
 *
 *   if (yang_type_get(ys, &type, &rtype, &options, &min, &max, &pattern) < 0)
 *      goto err;
 *   if (rtype == NULL) # unresolved
 *      goto err;
 *   if (options & YANG_OPTIONS_LENGTH != 0)
 *      printf("%d..%d\n", min , max);
 *   if (options & YANG_OPTIONS_PATTERN != 0)
 *      printf("regexp: %s\n", pattern);
 * @endcode
 * @param [in]  ys       yang-stmt, leaf or leaf-list
 * @param [out] otype    original type may be derived or built-in
 * @param [out] rtype    resolved type is built-in
 * @param [out] options  pointer to flags field of optional values
 * @param [out] min      pointer to min range or length. optional
 * @param [out] max      pointer to max range or length. optional
 * @param [out] pattern  pointer to static string of yang string pattern. optional
 * @retval      0        OK
 * @retval     -1        Error, clicon_err handles errors
 * Note that the static output strings (type, pattern) should be copied if used asap.
 * Note also that for all pointer arguments, if NULL is given, no value is assigned.
 * See also yang_type_resolve(). This function is really just a frontend to that.
 */
int 
yang_type_get(yang_stmt    *ys, 
	      char        **origtype, 
	      char        **rtype, 
	      int          *options, 
	      int64_t      *min, 
	      int64_t      *max, 
	      char        **pattern)
{
    int retval = -1;
    yang_stmt    *ytype;        /* type */
    char         *type;

    if (options)
	*options = 0x0;
    /* Find mandatory type */
    if ((ytype = yang_find((yang_node*)ys, Y_TYPE, NULL)) == NULL){
	clicon_err(OE_DB, 0, "%s: mandatory type object is not found", __FUNCTION__);
	goto done;
    }
    type = ytype->ys_argument;
    if (origtype)
	*origtype = type;
    if (yang_type_resolve(ys, ytype, rtype, options, min, max, pattern) < 0)
	goto done;
    clicon_debug(1, "%s: %s %s->%s\n", __FUNCTION__, ys->ys_argument, type, 
		 rtype?*rtype:"null");
    retval = 0;
  done:
    return retval;
}
