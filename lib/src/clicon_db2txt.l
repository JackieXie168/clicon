/*
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.
 */


%{

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h> 
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <assert.h>
#include <stdarg.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include "clicon_queue.h"
#include "clicon_log.h"
#include "clicon_err.h"
#include "clicon_hash.h"
#include "clicon_handle.h"
#include "clicon_dbspec_key.h"
#include "clicon_lvalue.h"
#include "clicon_db2txt.h"
#include "clicon_db2txt.y.h"
#include "clicon_db2txt.tab.h"

//#define DEBUG_NOFLEX 1

/* Dont use input function (use user-buffer) */
#define YY_NO_INPUT

#define YY_DECL int clicon_db2txtlex(void *_ya)

static int push_state(void *_ya, int state);
static int pop_state(void *_ya);

void
clicon_db2txterror(void *_ya, char *fmt, ...)
{
    int len = 1;
    char *str;
    va_list args;
    
    va_start(args, fmt);
    len = vsnprintf(NULL, 0, fmt, args) + 1;
    va_end (args);
    if ((str = malloc(len)) == NULL) {
	len = 0;
	str = "";
    }
    else  {
	va_start(args, fmt);
	vsnprintf(str, len, fmt, args);
	va_end (args);
    }
    
    if (_ya) {
	char *txt = NULL;
	switch (clicon_db2txttext[strlen(clicon_db2txttext)-1]) {
	  case EOF:
	  case '\0': txt = "EOF"; break;
	  case '\n': txt = "new-line"; break;
	  default:   txt = clicon_db2txttext; 
	}
	fprintf(stderr, "error: %s at or before '%s', in '%s', line %d",
		str, txt,
		_YA->ya_file_stack->name ? _YA->ya_file_stack->name : "_buffer_",
		_YA->ya_file_stack->line);
	if (_YA->ya_file_stack && _YA->ya_file_stack->name) 
	    fprintf(stderr, " in %s", _YA->ya_file_stack->name);
	fprintf(stderr, "\n");
	{
	    char *s;
	    extern char *db2txt_code_string(code_stack_t *cs);
	    s = db2txt_code_string(_YA->ya_code_stack);
	    db2txt_debug("Code stack = %s\n", s);
	}

    }
    else
	fprintf(stderr, "error: %s\n", str);
	
    if (len)
	free(str);
}

static int
append_loopbufs(void *_ya, char *token)
{
    char *new;
    size_t len;
    code_stack_t *cs;

//    fprintf(stderr, "APPEND: %s\n", token);
    if ((cs = (code_stack_t *)_YA->ya_code_stack) != NULL) {
	do {
	    if (cs->append_loopbuf) {
		len = cs->loopbuf ? strlen(cs->loopbuf) : 0;
		if ((new = realloc(cs->loopbuf, len+strlen(token)+1)) == NULL) {
		    clicon_err(OE_UNIX, errno, "malloc");
		    return -1;
		}
		cs->loopbuf = new;
		sprintf(cs->loopbuf + len, "%s", token);
	    }
	    cs = NEXTQ(code_stack_t *, cs);
	} while(cs != (code_stack_t *)_YA->ya_code_stack);
    }
    return 0;
}
#define APPBUF	{ \
  if(_YA->ya_prevtok) \
      free(_YA->ya_prevtok); \
   _YA->ya_prevtok = strdup(yytext); \
   append_loopbufs(_YA, yytext); \
}


int
db2txt_debug(const char *s, ...)
{
    int ret = 0;
#if defined(FLEX_DEBUG) || defined(DEBUG_NOFLEX)
    va_list args;
    
    va_start(args, s);
    ret = vfprintf(stderr, s, args);
    va_end (args);
#endif
    return ret;
}

%}

%option noyywrap

%s COMMENT
%s CODE
%s ESCAPE
%s STRING
%s VAR


%%

<INITIAL>\\		{ APPBUF; push_state (_YA, ESCAPE); }
<INITIAL>\n		{ APPBUF; _YA->ya_file_stack->line++; return NL; }
<INITIAL><<EOF>>	{ return MY_EOF; }
<INITIAL>#		{ 
    			  if(_YA->ya_prevtok == NULL ||
			     _YA->ya_prevtok[strlen(_YA->ya_prevtok)-1]=='\n')
			      _YA->ya_fullcomment = 1;
			  push_state (_YA, COMMENT); 
 			}
<INITIAL>\$		{ APPBUF;  push_state (_YA, VAR); return *yytext; }
<INITIAL>@[sS][eE][tT]	{ APPBUF;  push_state (_YA, CODE); return SET; }
<INITIAL>@[iI][fF]	{ APPBUF;  push_state (_YA, CODE); return IF; }
<INITIAL>@[eE][lL][sS][eE]	{ APPBUF;  return ELSE; }

<INITIAL>@[iI][nN][cC][lL][uU][dD][eE]	{ APPBUF;  push_state (_YA, CODE); return INCLUDE; }
<INITIAL>@[eE][aA][cC][hH]	{ APPBUF;  push_state (_YA, CODE); return EACH; }
<INITIAL>@[eE][nN][dD]	{ APPBUF;  return END; }
<INITIAL>.		{ APPBUF;  clicon_db2txtlval.character=*yytext;
			  return CHAR; }

<VAR>\(			{ APPBUF; push_state(_YA, CODE); unput('('); } /*cb call*/
<VAR><<EOF>>		{ pop_state(_YA); return MY_EOF; }
<VAR>\n			{ pop_state(_YA); unput(*yytext); }
<VAR>\}			{ APPBUF; pop_state(_YA); return *yytext; }
<VAR>[:\{\[\]]		{ APPBUF; return *yytext; }
<VAR>\-\>		{ APPBUF; return ARROW; }
<VAR>[a-zA-Z]([a-zA-Z0-9_]|[\-][a-zA-Z])*(\.([0-9]+|[a-zA-Z]([a-zA-Z0-9_]|[\-][a-zA-Z])*))* {
			  APPBUF;
			  clicon_db2txtlval.string = strdup(yytext);
			  return VARIABLE;
			}
<VAR>.			{ pop_state(_YA); unput(*yytext); }



<COMMENT>\n             {
			  pop_state(_YA); 
			  if (_YA->ya_fullcomment == 0)
			      unput(*yytext);
			  else
			      _YA->ya_file_stack->line++;
 			}
<COMMENT><<EOF>>        { return MY_EOF; }
<COMMENT>.

<CODE>[ \t]		{ APPBUF; }
<CODE>\n		{ APPBUF;  _YA->ya_file_stack->line++; }
<CODE>\(		{ APPBUF;
			  _YA->ya_lex_state->brackets++;
			  return '('; }   
<CODE>\)		{
    			  APPBUF; 
			  _YA->ya_lex_state->brackets--;
			  if (_YA->ya_lex_state->brackets <= 0)
			      pop_state(_YA);
			  return ')';
			}
<CODE>\$		{ APPBUF;  push_state(_YA, VAR); return *yytext; }
<CODE>\"                { APPBUF;  push_state(_YA, STRING); return *yytext; }
<CODE>!=		{ APPBUF; return NEQ; }
<CODE>==		{ APPBUF; return EQ; }
<CODE>\>		{ APPBUF; return GT; }
<CODE>\<		{ APPBUF; return LT; }
<CODE>\>=		{ APPBUF; return GTE; }
<CODE>\<=		{ APPBUF; return LTE; }
<CODE>:			{ APPBUF; return *yytext; }
<CODE>(nil)		{ APPBUF; return NIL; }
<CODE>(null)		{ APPBUF; return NIL; }
<CODE>[^ \t\n\(\)\$\"\!\=\>\<,\?:]+ {
			  APPBUF; 
			  clicon_db2txtlval.string = strdup(yytext);
			  return WORD;
 			}
<CODE>.			{ APPBUF; return *yytext; }

<STRING>\n               { APPBUF;
     			   _YA->ya_file_stack->line++; 
			   clicon_db2txtlval.character = *yytext;
			  return CHAR;
 			}
<STRING>\$		{ APPBUF;  push_state (_YA, VAR); return *yytext; }
<STRING>\\              { APPBUF;  push_state(_YA, ESCAPE); }
<STRING>\"              { APPBUF;  pop_state(_YA); return *yytext; }
<STRING>.               { APPBUF;
			  clicon_db2txtlval.character = *yytext;
			  return CHAR;
 			}

<ESCAPE>[nrt]           {
    			  APPBUF;  
			  pop_state(_YA);
			  switch(*yytext) {
			    case 'n': clicon_db2txtlval.character='\n'; break;
			    case 'r': clicon_db2txtlval.character='\r'; break;
			    case 't': clicon_db2txtlval.character='\t'; break;
			  }
			  return CHAR;
			}
<ESCAPE>.               { APPBUF;  pop_state(_YA);
			  clicon_db2txtlval.character=*yytext;
			  return CHAR;
			}

%%

static int
push_state(void *_ya, int state)
{
    state_t *st;
    
    if ((st = malloc(sizeof(*st))) == NULL) {
	clicon_db2txterror(NULL, "Failed to allocate state stack entry");
	return -1;
    }
    memset(st, 0, sizeof(*st));
    
    st->state = state;
    INSQ(st, _YA->ya_lex_state);
    
    BEGIN(state);
    
    db2txt_debug("push_state: New state: %d\n", state);
    return state;
}

static int
pop_state(void *_ya)
{
    state_t *st;
    
    st = _YA->ya_lex_state;
    if (st == NULL || NEXTQ(state_t *, st) == st) {
        clicon_db2txterror(NULL, "State stack underflow!\n");
	return -1;
    }
    DELQ(st, _YA->ya_lex_state, state_t *);
    free(st);
    
    BEGIN(_YA->ya_lex_state->state);
    
    db2txt_debug("pop_state: New state: %d\n", _YA->ya_lex_state->state);
    return _YA->ya_lex_state->state;
}

#if 0
/*
 * Read file and strore in a string
 */
char *
clicon_db2txt_fread(void *_ya, const char *file)
{
    FILE *f;
    char *txt;
    struct stat st;

    if (stat(file, &st) != 0) {
	clicon_err(OE_UNIX, errno, "stat");
	return NULL;
    }

    if ((txt = malloc(st.st_size+1)) == NULL) {
	clicon_err(OE_UNIX, errno , "malloc");
	return NULL;
    }
    memset(txt, '\0', st.st_size+1);

    if ((f = fopen(file, "r")) == NULL) {
	clicon_err(OE_UNIX, errno, "fopen");
	free(txt);
	return NULL;
    }

    if (fread(txt, 1, st.st_size, f) < 0) {
	clicon_err(OE_UNIX, errno, "read");
	fclose(f);
	free(txt);
	return NULL;
    }

    fclose(f);
    
    return txt;
}
#endif


file_stack_t *
db2txt_file_new(char *file)
{
    file_stack_t *fs;

    if ((fs = malloc(sizeof(*fs))) == NULL) {
	clicon_err(OE_UNIX, errno, "malloc");
	return NULL;
    }
    memset(fs, 0, sizeof(*fs));
    fs->line = 1;
    
    if ((fs->name = strdup(file)) == NULL) {
	free(fs);
	clicon_err(OE_UNIX, errno, "strdup");
	return NULL;
    }
    
    if ((fs->fp = fopen(file, "r")) == NULL) {
	free(fs->name);
	free(fs);
	clicon_err(OE_UNIX, errno, "fopen");
	return NULL;
    }
    
    return fs;
}

static file_stack_t *
db2txt_buf_new(char *txt)
{
    char *buf;
    file_stack_t *fs;

    if ((buf = strdup(txt)) == NULL) {
	clicon_err(OE_UNIX, errno, "strdup");
	return NULL;
    }
    if ((fs = malloc(sizeof(*fs))) == NULL) {
	clicon_err(OE_UNIX, errno, "malloc");
	return NULL;
    }
    memset(fs, 0, sizeof(*fs));
    fs->line = 1;
    
    fs->name = NULL;
    fs->buf = buf;
    
    return fs;
}


#if 0
static void
db2txt_filestack_free(file_stack_t *fs)
{
    file_stack_t *next;
    
    if (fs == NULL)
	return;

    do {
	if ((next = NEXTQ(file_stack_t *, fs)) == fs)
	    next = NULL;
	db2txt_file_free(fs);
	fs = next;
    } while(fs);
}
#endif

int
db2txt_pushbuf(db2txt_t *dbt, YY_BUFFER_STATE state)
{
    buffer_stack_t *bs;

    if ((bs = malloc(sizeof(*bs))) == NULL)
	return -1;

    bs->buffer = state;
    INSQ(bs, dbt->ya_buffer_stack);

    yy_switch_to_buffer(state);

    push_state(dbt, INITIAL);
    db2txt_debug("Pushing buffer %p\n", state);
    return 0;
}

/*
 * Wrapper as YY_BUFFER_STATE and yy_scan_string doesn't exist in parser
 */
int
db2txt_pushtxt(db2txt_t *dbt, char *txt)
{
    if ( db2txt_pushbuf(dbt, yy_scan_string(txt)) != 0)
	return -1;
    
    return 0;
}

void *
db2txt_popbuf(db2txt_t *dbt)
{
    buffer_stack_t *bs;

    if ((bs = dbt->ya_buffer_stack) == NULL)
	return NULL;
    
    db2txt_debug("Popping buffer %p\n", YY_CURRENT_BUFFER);
    DELQ(bs, dbt->ya_buffer_stack, buffer_stack_t *);
    yy_delete_buffer( YY_CURRENT_BUFFER );
    free(bs);

    if ((bs = dbt->ya_buffer_stack) == NULL)
	return NULL;
    yy_switch_to_buffer(bs->buffer);
    pop_state(dbt);

    return (void *)YY_CURRENT_BUFFER;
}


int
db2txt_pushfile(db2txt_t *dbt, file_stack_t *fs)
{
    YY_BUFFER_STATE state;

    if (fs->fp)
	state = yy_create_buffer (fs->fp, YY_BUF_SIZE);
    else
	state = yy_scan_string(fs->buf);	

    INSQ(fs, dbt->ya_file_stack);
    return db2txt_pushbuf(dbt, state);
}

void
db2txt_popfile(db2txt_t *dbt)
{
    file_stack_t *fs;

    fs = dbt->ya_file_stack;
    db2txt_popbuf(dbt);
    DELQ(fs, dbt->ya_file_stack, file_stack_t *);

    if (fs->name)
	free(fs->name);
    if (fs->buf)
	free(fs->buf);
    if (fs->fp)
	fclose(fs->fp);
    free(fs);    
}

static void
db2txt_exit(db2txt_t *d2t)
{
    state_t *st;

    while(db2txt_popbuf((void *)d2t))
	;
    if (d2t->ya_prevtok)
	free(d2t->ya_prevtok);
    if (d2t->ya_vars)
	cvec_free(d2t->ya_vars);
    if (d2t->ya_null)
	cv_free(d2t->ya_null);
    while(d2t->ya_code_stack)
	db2txt_parser_cleanup(d2t);
    while(d2t->ya_file_stack)
	db2txt_popfile(d2t);
    while((st = d2t->ya_lex_state) != NULL) {
	DELQ(st, d2t->ya_lex_state, state_t *);
	free(st);
    }

#if defined(YY_FLEX_SUBMINOR_VERSION) && YY_FLEX_SUBMINOR_VERSION >= 9
    clicon_db2txtlex_destroy();
#else
    yy_init = 1;      /* This does not quite free all buffers */
#endif
}

static db2txt_t *
db2txt_init()
{
    db2txt_t *d2t;

    d2t = malloc(sizeof(*d2t));
    if (d2t == NULL) {
	clicon_err(OE_UNIX, errno, "malloc");
	return NULL;
    }
    
    memset(d2t, 0, sizeof(*d2t));
    if ((d2t->ya_null = cv_new(CGV_ERR)) == NULL) {
	clicon_err(OE_UNIX, errno, "cv_new");
	free(d2t);
	return NULL;
    }
    
    if ((d2t->ya_vars = cvec_new(0)) == NULL) {
	db2txt_exit(d2t);
	free(d2t);
	return NULL;
    }
    
    if((d2t->ya_ret = strdup("")) == NULL) {
	db2txt_exit(d2t);
	free(d2t);
	return NULL;
    }

    return d2t;
}

/*
 * clicon_db2txt_parse
 */ 
static char *
db2txt_parse_txt(clicon_handle h, char *db, file_stack_t *fs)
    
{
    char *result = NULL;
    db2txt_t *d2t;

    if ((d2t = db2txt_init()) == NULL)
	return NULL;

    d2t->ya_db = db;
    d2t->ya_handle = h;
#if 0
    d2t->ya_cb = cb;
    d2t->ya_cbarg = cbarg;
#endif
    INSQ(fs, d2t->ya_file_stack);
    db2txt_pushfile(d2t, fs);

    if (clicon_db2txtparse((void *)d2t) != 0)
        goto quit;
    result = d2t->ya_ret;


quit:
    if (result == NULL && d2t->ya_ret)
	free(d2t->ya_ret);
    db2txt_exit(d2t);
    free(d2t);

    return result;
}



/*
 * Parse file
 */
char *
clicon_db2txt(clicon_handle h, char *db, char *file)
{
    file_stack_t *fs;

    if ((fs = db2txt_file_new(file)) == NULL)
	return NULL;

    return db2txt_parse_txt(h, db, fs);
}
    
/*
 * Parse file
 */
char *
clicon_db2txt_buf(clicon_handle h, char *db, char *buf)
{
    file_stack_t *fs;

    if ((fs = db2txt_buf_new(buf)) == NULL)
	return NULL;

    return db2txt_parse_txt(h, db, fs);
}
    
    
    
    
    
