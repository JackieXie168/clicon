/*
 *  CVS Version: $Id: clicon_dbvars.c,v 1.10 2013/09/18 19:16:10 olof Exp $
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 */


#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <inttypes.h>
#include <errno.h>

#include <cligen/cligen.h>

#include "clicon_queue.h"
#include "clicon_log.h"
#include "clicon_err.h"
#include "clicon_string.h"
#include "clicon_chunk.h"
#include "clicon_hash.h"
#include "clicon_handle.h"
#include "clicon_spec.h"
#include "clicon_lvalue.h"
#include "clicon_db.h"
#include "clicon_dbutil.h"
#include "clicon_dbvars.h"


/*
 * Assign the next sequence number for a vector variable.
 */
static int
clicon_dbvars_seq(char *db, char *key, clicon_dbvars_t *dbv)
{
    cg_var     *cv = NULL;
    int        ival;

    cv = NULL;
    while ((cv = cvec_each(dbv->dbv_vec, cv))) {
	if (cv_flag(cv, V_SEQ)) {
	    ival = lv_next_seq(db, key, cv_name_get(cv), cv_int_get(cv));
	    if (ival < 0) {
		clicon_debug(1, "%s: lv_next_seq < 0\n", __FUNCTION__);
		return -1;
	    }
	    cv_int_set(cv, ival);
	}
    }
    
    return 0;
}

void
clicon_dbvars_free(clicon_dbvars_t *dbv)
{
    if (dbv->dbv_key)
	free(dbv->dbv_key);
    if (dbv->dbv_vec)
	cvec_free(dbv->dbv_vec);
    free(dbv);
}


/*
 * Parse a string format string populating variables with values from cligen 
 * argument vector. See comment above clicon_dbvars_parse_fmt() for syntax.
 *
 * The syntax supports populating a variable value by calling a callback 
 * function as well. The calback is specified as string naming the function
 * and optionally also the plugin name. It is therefore not intended
 * that the callback function pointer is the function that will actually
 * return the value of the variable, but only use the name of the plugin and
 * function to to a dlsym lookup to find the actual function.
 *
 * Typically this function is called by the clicon cli engine and 'cb'
 * is a function in the same that will resolve application plugin 
 * function names and relaying the call. The cb_arg is passed to 'cb'
 * and can contain a pointer to anything, for example the cli_handle.
 *
 * Once the variable list has been built, it is used to format the final
 * key including vector indexes. 
 * Any sequence variables will also be given values based on existing 
 * sequence values in a vector.
 */
clicon_dbvars_t *
clicon_dbvars_parse(struct db_spec *spec, 
		   char *db, 
		   cvec *vars,
		   const char *fmt,
		   clicon_dbvalcb_t *cb,
		   void *cb_arg)	/* user arg passed back to callback */

{
    char *key;
    clicon_dbvars_t *dbv;
    clicon_dbvars_t *clicon_dbvars_parse_fmt(cvec *, const char *, clicon_dbvalcb_t *, void *);

    if ((dbv = clicon_dbvars_parse_fmt(vars, fmt, cb, cb_arg)) == NULL)
	return NULL;
    
    /* Format key, resolving variables and mid-key vectors */
    key = db_lv_op_keyfmt (spec, db, dbv->dbv_key, dbv->dbv_vec, __FUNCTION__);
    if (key == NULL)
	goto err;

    free(dbv->dbv_key);
    if ((dbv->dbv_key = strdup(key)) == NULL)
	goto err;
    
    /* Substitute sequence numbers */
    if (clicon_dbvars_seq(db, key, dbv) < 0)
	goto err;

    unchunk_group(__FUNCTION__);
    return dbv;

err:
    if (dbv)
	clicon_dbvars_free(dbv);
    unchunk_group(__FUNCTION__);

    return NULL;
}
