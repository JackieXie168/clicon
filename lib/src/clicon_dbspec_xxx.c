/*
 *  CVS Version: $Id: clicon_spec.c,v 1.29 2013/09/19 16:03:40 olof Exp $
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 * This is an extract and copy of cligen necessary files for dbcli parser to work.
 * Plan is to replace this with yang parser.
  */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#ifdef USE_DBSPEC_PT


#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#define __USE_GNU /* strverscmp */
#include <string.h>
#include <arpa/inet.h>
#include <regex.h>
#include <syslog.h>
#include <assert.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include "clicon_log.h"
#include "clicon_err.h"
#include "clicon_string.h"
#include "clicon_queue.h"
#include "clicon_hash.h"
#include "clicon_handle.h"
#include "clicon_spec.h"
#ifdef USE_DBSPEC_PT
#include "clicon_dbspec_parsetree.h"
#endif /* USE_DBSPEC_PT */
#include "clicon_hash.h"
#include "clicon_lvalue.h"
#include "clicon_lvmap.h"
#include "clicon_chunk.h"
#include "clicon_yang.h"
#include "clicon_options.h"
#include "clicon_dbutil.h"
#include "clicon_dbspec_xxx.h"

int
cv_validate2(cg_var *cv, cg_varspec2 *cs, char **reason)
{
    int retval = 1; /* OK */
    long long i = 0;

    switch (cs->cgs_vtype){
    case CGV_INT:
	i = cv_int_get(cv);
    case CGV_LONG: /* fallthru */
	 /* Check range if specified */
	if (cs->cgs_vtype == CGV_LONG)
	    i = cv_long_get(cv);
	if (cs->cgs_range){
	    if (i < cs->cgs_range_low || i > cs->cgs_range_high) {
		if (reason)
		    *reason = cligen_reason("Number out of range: %i", i);
		retval = 0;
	    }
	}
    case CGV_STRING:
	if (cs->cgs_regex == NULL)
	    break;
	if ((retval = match_regexp(cv_string_get(cv), cs->cgs_regex)) < 0)
	    break;
	if (retval == 0){
	    if (reason)
		*reason = cligen_reason("regexp match fail: %s does not match %s",
					cv_string_get(cv), cs->cgs_regex);
	    retval = 0;
	}
	break;
    case CGV_ERR:
    case CGV_VOID:
	retval = 0;
	if (reason)
	    *reason = cligen_reason("Invalid cv");
	retval = 0;
	break;
    case CGV_BOOL:
    case CGV_INTERFACE:
    case CGV_REST:
    case CGV_IPV4ADDR: 
    case CGV_IPV6ADDR: 
    case CGV_IPV4PFX: 
    case CGV_IPV6PFX: 
    case CGV_MACADDR:
    case CGV_URL: 
    case CGV_UUID: 
    case CGV_TIME: 
	break;
    }
    if (reason && *reason)
	assert(retval == 0);
    return retval;
}


/*! Apply a function call recursively on all cg_obj:s in a parse-tree
 *
 * Recursively traverse all cg_obj in a parse-tree and apply fn(arg) for each
 * object found. The function is called with the cg_obj and an argument as args.
 */
int
pt_apply2(dbspec_tree pt, cg_applyfn2_t fn, void *arg)
{
    dbspec_obj *co;
    int     i;
    int     retval = -1;

    if (pt.dt_vec == NULL)
	return 0;
    for (i=0; i<pt.dt_len; i++){
	if ((co = pt.dt_vec[i]) == NULL)
	    continue;
	if (fn(co, arg) < 0)
	    goto done;
	if (pt_apply2(co->do_pt, fn, arg) < 0)
	    goto done;
    }
    retval = 0;
  done:
    return retval;
}



/* 
 * Create new cligen parse-tree object
 */
dbspec_obj *
co_new2(char *cmd, dbspec_obj *prev)
{
    dbspec_obj *co;

    if ((co = malloc(sizeof(dbspec_obj))) == NULL){
	perror("co_new: malloc");
	return NULL;
    }
    memset(co, 0, sizeof(dbspec_obj));
    co->do_type    = CO_COMMAND;
    co->do_command = strdup(cmd);
    co_up_set2(co, prev);

    co->do_next = NULL;

    return co;
}

static int
pt_free12(dbspec_tree pt, int recursive)
{
    int i;

    if (pt.dt_vec == NULL)
	return 0;
    for (i=0; i<pt.dt_len; i++)
	if (pt.dt_vec[i])
	    co_free2(pt.dt_vec[i], recursive);
    free(pt.dt_vec);
    pt.dt_vec = NULL;
    pt.dt_len = 0;
    return 0;
}


int 
co_free2(dbspec_obj *co, int recursive)
{
    if (recursive && co->do_next)
	pt_free12(co->do_pt, 1); /* recursive */
    if (co->do_help)
	free(co->do_help);
    if (co->do_command)
	free(co->do_command);

    if (co->do_userdata)
	free(co->do_userdata);

    if (co->do_type == CO_VARIABLE){
	if (co->do_choice)
	    free(co->do_choice);
	if (co->do_regex)
	    free(co->do_regex);
    }
#ifdef notyet
    if (co->co_cv)
	cv_free(co->co_cv);
#endif
    free(co);
    return 0;
}

int
cligen_parsetree2_free(dbspec_tree pt, int recursive)
{
    return pt_free12(pt, recursive);
}


static inline int
str_cmp(char *s1, char *s2)
{
    if (s1 == NULL && s2 == NULL) 
	return 0;
    if (s1 == NULL) /* empty string first */
	return -1;
    if (s2 == NULL)
	return 1;
    /*
     * XXX: the cligen handler code uses NULL here which is wrong, but those
     * options are for now global settings.
     */
#ifdef  HAVE_STRVERSCMP
    if (cligen_lexicalorder(NULL))
	return strverscmp(s1, s2); /* can't combine lexicalorder and ignorecase */
    else
	return cligen_ignorecase(NULL) ? strcasecmp(s1, s2) : strcmp(s1, s2);
#else /* HAVE_STRVERSCMP */
    return cligen_ignorecase(NULL) ? strcasecmp(s1, s2) : strcmp(s1, s2);
#endif /* HAVE_STRVERSCMP */
}


static int 
co_eq2(dbspec_obj *co1, dbspec_obj *co2)
{
    int eq;

    /* eq == 0 means equal */
    eq = !(co1->do_type == co2->do_type);
    if (eq){ /* special case, keywords */
	if (co1->do_type == CO_COMMAND && 
	    co2->do_vtype == CGV_STRING && 
	    iskeyword2(co2)){
	    if ((eq = strcmp(co1->do_command, co2->do_keyword)) == 0)
		goto done;
	}
	else
	if (co2->do_type == CO_COMMAND && 
	    co1->do_vtype == CGV_STRING && 
	    iskeyword2(co1))
	    eq = strcmp(co2->do_command, co1->do_keyword);
	else
	    eq = str_cmp(co1->do_command, co2->do_command);
	goto done;
    }
    switch (co1->do_type){
    case CO_COMMAND:
	eq = str_cmp(co1->do_command, co2->do_command);
	break;
    case CO_REFERENCE:
	eq = str_cmp(co1->do_command, co2->do_command);
	break;
    case CO_VARIABLE:
	eq = str_cmp(co1->do_command, co2->do_command); /* XXX: 2012-10-17: Really a bug if I didnt detect this until now,... */
	/* Same variable type */
	if (eq != 0)
	    goto done;
	eq = (co1->do_vtype == co2->do_vtype)?0:(co1->do_vtype < co2->do_vtype)?-1:1;
	/* Same variable type */
	if (eq != 0)
	    goto done;

	/* Examine choice: at least one set, and then strcmp */
	if (co1->do_choice!=NULL || co2->do_choice!=NULL){
	    eq = str_cmp(co1->do_choice, co2->do_choice);
	    goto done;
	}
	/* Examine regexp, at least one set, and then strcmp */
	if (co1->do_regex!=NULL || co2->do_regex!=NULL){
	    eq = str_cmp(co1->do_regex, co2->do_regex);
	    goto done;
	}
	/* Examine int and range */
	if (co1->do_vtype == CGV_INT || co1->do_vtype == CGV_LONG){
	    if (co1->do_range == co2->do_range){
		eq = 0;
		goto done;
	    }
	    else
		if (co1->do_range){ /* both ranges set */
		    if ((co1->do_range_low == co2->do_range_low) &&
			(co1->do_range_high == co2->do_range_high)){
			    eq = 0;
			    goto done;
			}
		    if ((eq = co2->do_range_low - co1->do_range_low) != 0)
			goto done;
		    eq = co2->do_range_high - co1->do_range_high;
		    goto done;
		}
	}
	break;
    }
  done:
    return eq;
}


/* 
 * co_insert_pos2
 * at what position to insert <name>
 */
static int
co_insert_pos2(dbspec_tree pt, dbspec_obj *co1, int low, int high)
{
    int     mid;
    int     cmp;
    dbspec_obj *co2;

    if (high < low)
	return low; /* not found */
    mid = (low + high) / 2;
    if (mid >= pt.dt_len)
	return pt.dt_len; 
    if (co1 == NULL)
	return 0; /* Insert in 1st pos */
    co2 = pt.dt_vec[mid];
    /* XXX: MATCHING PROBLEM: 
       should be same as in co_insert
     */
#if 0
    cmp = str_cmp(co1->do_command, co2 ? co2->do_command : NULL);
#else
    if (co2 == NULL)
	cmp = 1;
    else{
#if 1
	cmp = co_eq2(co1, co2);
#else
        cmp = str_cmp(co1->do_command, co2->do_command);
#endif
    }
#endif
    if (cmp < 0)
	return co_insert_pos2(pt, co1, low, mid-1);
    else if (cmp > 0)
	return co_insert_pos2(pt, co1, mid+1, high);
    else
	return mid;
}

static int 
pt_realloc2(dbspec_tree *pt)
{
    pt->dt_len++;
    /* Allocate larger cg_obj vector */
    if ((pt->dt_vec = realloc(pt->dt_vec, (pt->dt_len)*sizeof(dbspec_obj *))) == 0){
	fprintf(stderr, "%s: realloc", __FUNCTION__);
	return -1;
    }
    pt->dt_vec[pt->dt_len - 1] = NULL; /* init field */
    return 0;
}


/*
 * co_insert2
 * Add a cligen object (co1) to a parsetree(pt) alphabetically.
 * This involves searching in the parsetree for the position where it should be added,
 * Then checking whether an equivalent version already exists.
 * Then modifying the parsetree by shifting it down, and adding the new object.
 * There is som complexity if co == NULL.

 * Return value:
 *   co object if found (old _or_ new). NOTE: you must replace calling cg_obj with return.
 *   NULL error
 */
dbspec_obj*
co_insert2(dbspec_tree *pt, dbspec_obj *co1)
{
    int pos;
    size_t size;
    dbspec_obj *co2;

    /* find closest to co in parsetree, last one that is < co */
    pos = co_insert_pos2(*pt, co1, 0, pt->dt_len);
    /* check if exists */
    if (pos < pt->dt_len){
	co2 = pt->dt_vec[pos];
	if (co1 == NULL && co2==NULL)
	    return NULL;
	/* XXX: MATCHING PROBLEM:
	   Note, there is a subtle difference between co_eq and
	   equality in str_cmp, so maybe we should use str_cmp instead? 
	   At least, equality should be the same as in co_insert_pos()
	*/
#if 1
	if (co1 && co2 && co_eq2(co1, co2)==0)
#else
	if (co1 && co2 && !str_cmp(co1->do_command, co2->do_command))
#endif
{
	    co_free2(co1, 1);
	    return co2;
	}
    }
    if (pt_realloc2(pt) < 0)
	return NULL;
    if ((size = (pt->dt_len - (pos+1))*sizeof(dbspec_obj*)) != 0)
	memmove(&pt->dt_vec[pos+1], 
		&pt->dt_vec[pos], 
		size);
    pt->dt_vec[pos] = co1;
    return co1;
}

static dbspec_obj *
co_search12(dbspec_tree pt, char *name, int low, int high)
{
    int     mid;
    int     cmp;
    dbspec_obj *co;

    if (high < low)
	return NULL; /* not found */
    mid = (low + high) / 2;
    if (mid >= pt.dt_len)  /* beyond range */
	return NULL;
    co = pt.dt_vec[mid];
    cmp = str_cmp(name, co ? co->do_command : NULL);
    if (cmp < 0)
	return co_search12(pt, name, low, mid-1);
    else if (cmp > 0)
	return co_search12(pt, name, mid+1, high);
    else
	return co;
}

dbspec_obj *
co_find_one2(dbspec_tree pt, char *name)
{
  return co_search12(pt, name, 0, pt.dt_len);
}
#endif /* USE_DBSPEC_PT */
