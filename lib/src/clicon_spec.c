/*
 *  CVS Version: $Id: clicon_spec.c,v 1.29 2013/09/19 16:03:40 olof Exp $
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 * Database specification
 * Syntax:
 * <line> ::= <key> <var>*
 * <var>  ::= $[!]<name>[:<type>]
 * Example: system.hostname a:string !b:number
 * Comment sign is '#'
 * The resulting parse-tree is in a linked list of db_spec:s
 * Each db_spec contains a key and a variable-headm which in turn contains
 * a list of variables (see osr_var.h).
 *
 * Translation between databsae specs
 *     db_spec                      parse_tree                    parse_tree
 *  +-------------+ dbspec_key2cli +-------------+ dbspec2cli    +-------------+
 *  |  dbspec     | -------------> | dbclispec   | ------------> | cli         |
 *  |  A[].B !$a  | dbspec_cli2key | A <!a>{ B;} |               | syntax      |
 *  +-------------+ <------------  +-------------+               +-------------+
 *        ^                               ^
 *        |db_spec_parse_file             | dbclispec_parse
 *        |                               |
 *      <file>                          <file>
  */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <arpa/inet.h>
#include <regex.h>
#include <syslog.h>
#include <assert.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include "clicon_log.h"
#include "clicon_err.h"
#include "clicon_string.h"
#include "clicon_queue.h"
#include "clicon_hash.h"
#include "clicon_handle.h"
#include "clicon_spec.h"
#include "clicon_hash.h"
#include "clicon_lvalue.h"
#include "clicon_lvmap.h"
#include "clicon_chunk.h"
#include "clicon_options.h"
#include "clicon_dbutil.h"
#include "clicon_dbspec.h"

struct db_spec *
db_spec_new(void)
{
  struct db_spec *ds;

  if ((ds = (struct db_spec *)malloc (sizeof (struct db_spec))) == NULL)
    return NULL;
  memset (ds, 0, sizeof (struct db_spec));
  return ds;
}

static int
db_spec_free1(struct db_spec *ds)
{
    cvec_free(ds->ds_vec);
    assert(ds->ds_key);
    free(ds->ds_key); 
    free(ds);
    return 0;
}

/*
 * \brief Add db_spec element to end of list. Merge vars if same key
 * 
 * Note, ds may be freed.
 */
int
db_spec_tailadd(struct db_spec **ds_list, struct db_spec *ds)
{
    struct db_spec **dsp = ds_list;
    struct db_spec  *ds1;
    cg_var          *cv;
    cg_var          *cv2;

    while (*dsp){
	ds1 = *dsp;
	if (strcmp(ds1->ds_key, ds->ds_key) == 0){ /* same key? */
	    cv = NULL;
	    /* Go thru vars in the new key and see if exists in old */
	    while ((cv = cvec_each(ds->ds_vec, cv)) != NULL) {
		if (cvec_find(ds1->ds_vec, cv_name_get(cv)) == NULL){
		    /* Add if not found */
		    if ((cv2 = cvec_add(ds1->ds_vec, cv_type_get(cv))) == NULL){
			clicon_err(OE_UNIX, errno, "cvvec_add");
			goto done;
		    }
		    if (cv_cp(cv2, cv) != 0) {
			clicon_err(OE_UNIX, errno, "cv_cp");
			goto done;
		    }
		}
	    }
	    db_spec_free1(ds); /* already in list, remove */
	    goto done; 
	}
	dsp = &(*dsp)->ds_next;
    }
    *dsp = ds;
  done:
    return 0;
}


/*
 * parse_line
 * <line> ::= <key> <var>*
 * <var>  ::= $[!]<name>[:<type>]
 * <var>  ::= $[!]<name>[:<type>][=<val>]
 */
static int
parse_line(char *line, int linenr, const char *filename, struct db_spec **list)
{
    int retval = -1;
    char  **vec;
    char   *var;
    char   *typeval;
    char   *type = NULL;
    char   *val = NULL;
    int     i;
    int     nvec;
    struct db_spec  *dbp;
    cvec            *vr;
    int              unique;
    cg_var          *newcv = NULL; 
    enum cv_type    cv_type;

    /* isue with trim of spaces ? */
    if ((vec = clicon_sepsplit(line, " \t", &nvec, __FUNCTION__)) == NULL)
	goto catch;
    if (nvec==0 || (nvec == 1 && !strlen(vec[0]))) // ignore empty
	goto catch;
    if ((dbp = db_spec_new()) == NULL)
	goto catch;
    if ((vr = cvec_new(0)) == NULL)
	goto catch;
    for (i=1; i<nvec; i++){
	unique = 0;
	if (!strlen(vec[i]))
	    continue;
	if (*vec[i] != '$'){ /* only variables accepted */
	    clicon_log(LOG_WARNING, "%s line:%d '%s' not variable (prepend with $)", 
		       filename, linenr, vec[i]);
	    continue;
	}
	vec[i]++;
	/* separate var into variable name and type+default */
	if (clicon_sep(vec[i], ":", __FUNCTION__, &var, &typeval) < 0)
	    goto catch;
	if (strlen(var) == 0){
	    clicon_log(LOG_WARNING, "db_spec_file line:%d '%s' no variable name", 
		    linenr, vec[i]);
	    continue;
	}
	/* separate typeval into type=default */
	type = NULL; val = NULL;
	if (typeval && clicon_sep(typeval, "=", __FUNCTION__, &type, &val) < 0)
	    goto catch;
	if (*var == '!'){
	    unique++;
	    var++;
	}
	if ((cv_type = cv_str2type(type?type:"string")) == CGV_ERR){
	    clicon_log(LOG_WARNING, "db_spec_file line:%d '%s' is not a cgv type", 
		    linenr, type);
	    continue;
	}
	if ((newcv = cvec_add(vr, cv_type)) == NULL) {
	    clicon_err(OE_UNIX, errno, "Allocating cligen object"); 
	    goto catch;
	}
	if (cv_name_set(newcv, var) == NULL) {
	    clicon_err(OE_UNIX, errno, "cv_name_set"); 
	    goto catch;
	}
	/* Default values */
	if (val != NULL){ 
	    if (cv_parse (val, newcv) < 0){
		clicon_log(LOG_WARNING, "db_spec_file line:%d '%s' malformed default value %s", 
			   linenr, val);
		goto catch;
	    }
	}
	else 
	    cv_flag_set(newcv, V_UNSET);

	if (unique)
	    cv_flag_set(newcv, V_UNIQUE);
    } /* for */
    /* Add this cvec to the spec */
    if ((dbp = db_spec_new()) == NULL)
	goto catch;
    dbp->ds_vec = vr;
    dbp->ds_key = strdup(vec[0]);
    db_spec_tailadd(list, dbp); /* dbp may be freed */
    retval = 0;
  catch:
    unchunk_group(__FUNCTION__);
    return retval;
}

/*
 * db_spec_parse
 * Parse a db specification from text format to parse-tree format, used 
 * internally in syntax-checking functions (such as key2spec_key()).
 * Free the returned parse-tree with db_spec_free()
 * (Only way to create a db_spec)
 * Return value:
 * db_spec - specification
 */
struct db_spec *
db_spec_parse_file(const char *filename)
{
    char   *ptr;
    int     len;
    char   *start;
    int     linenr = 1;
    char    line[1024];
    struct db_spec *db_spec_list = NULL; 
    FILE   *f;
    if ((f = fopen(filename, "r")) == NULL){
	clicon_err(OE_UNIX, errno, "fopen(%s)", filename);	
	return NULL;
    }
    while (fgets(line, sizeof(line), f)) {
	ptr = start = (char*)line;
	while (*ptr != '\0'){ 	/* read line */
	    if (*ptr == '#'){ /* comment */
		*ptr = '\0';
		break;
	    }
	    if (*ptr == '\n'){
		*ptr = '\0';
		break;
	    }
	    ptr++;
	}
	len = ptr-start;
	if (len)
	    if (parse_line(line, linenr, filename, &db_spec_list) < 0)
		goto catch;
	linenr++;
    }
  catch:
    fclose(f);

    return db_spec_list;
}

/*!
 * \brief Parse a string containing a CLICON dbspec into a parse-tree
 * 
 * Syntax parsing. A string is input and a syntax-tree is returned (or error). 
 * A variable record is also returned containing a list of (global) variable values.

 * (cloned from cligen)
 */
static int
clicon_dbspec_parse_str(clicon_handle h,
		 char *str,
		 const char *name, /* just for errs */
		 parse_tree *pt,
		 cvec *vr
    )
{
    int                retval = -1;
    int                i;
    struct clicon_dbspec_yacc_arg ya = {0,};
    cg_obj            *co;
    cg_obj             co0; /* tmp top object: NOT malloced */
    cg_obj            *co_top = &co0;

    memset(&co0, 0, sizeof(co0));
    ya.ya_handle       = h; 
    ya.ya_name         = (char*)name;
    ya.ya_linenum      = 1;
    ya.ya_parse_string = str;
    ya.ya_stack        = NULL;
    co_top->co_pt      = *pt;
    if (vr)
	ya.ya_globals       = vr; 
    else
	if ((ya.ya_globals = cvec_new(0)) == NULL){
	    fprintf(stderr, "%s: malloc: %s\n", __FUNCTION__, strerror(errno)); 
	    goto done;
	}

    if (strlen(str)){ /* Not empty */
	if (dbspec_scan_init(&ya) < 0)
	    goto done;
	if (dbspec_parse_init(&ya, co_top) < 0)
	    goto done;
	if (clicon_dbspecparse(&ya) != 0) {
	    dbspec_parse_exit(&ya);
	    dbspec_scan_exit(&ya);
	    goto done;
	}
	if (dbspec_parse_exit(&ya) < 0)
	    goto done;		
	if (dbspec_scan_exit(&ya) < 0)
	    goto done;		
    }
    if (vr)
	vr= ya.ya_globals;
    else
	cvec_free(ya.ya_globals);
    /*
     * Remove the fake top level object and remove references to it.
     */
    *pt = co_top->co_pt;
    for (i=0; i<co_top->co_max; i++){
	co=co_top->co_next[i];
	if (co)
	    co_up_set(co, NULL);
    }
    retval = 0;
  done:
    return retval;

}


/*! 
 * \brief Parse a file containing a CLICON dbspec into a parse-tree
 *
 * Similar to clicon_dbspec_str(), just read a file first
 * (cloned from cligen)
 * The database symbols are inserted in alphabetical order.
 */
static int
clicon_dbspec_parse_file(clicon_handle h,
		   FILE *f,
		   const char *name, /* just for errs */
		   parse_tree *pt,
		   cvec *globals)
{
    char         *buf;
    int           i;
    int           c;
    int           len;
    int           retval = -1;

    len = 1024; /* any number is fine */
    if ((buf = malloc(len)) == NULL){
	perror("pt_file malloc");
	return -1;
    }
    memset(buf, 0, len);

    i = 0; /* position in buf */
    while (1){ /* read the whole file */
	if ((c =  fgetc(f)) == EOF)
	    break;
	if (len==i){
	    if ((buf = realloc(buf, 2*len)) == NULL){
		fprintf(stderr, "%s: realloc: %s\n", __FUNCTION__, strerror(errno));
		goto done;
	    }	    
	    memset(buf+len, 0, len);
	    len *= 2;
	}
	buf[i++] = (char)(c&0xff);
    } /* read a line */
    if (clicon_dbspec_parse_str(h, buf, name, pt, globals) < 0)
	goto done;
    retval = 0;
  done:
    if (buf)
	free(buf);
    return retval;
}

/*
 * \brief Parse dbspec using cligen spec format
 *
 * The database symbols are inserted in alphabetical order.
 */
int
dbclispec_parse(clicon_handle h, const char *filename, parse_tree *pt)
{
    FILE       *f;
    cvec       *cvec = NULL;   /* global variables from syntax */
    int         retval = -1;
    char       *name;

    if ((f = fopen(filename, "r")) == NULL){
	clicon_err(OE_UNIX, errno, "fopen(%s)", filename);	
	goto done;
    }
    if ((cvec = cvec_new(0)) == NULL){ /* global variables from syntax */
	clicon_err(OE_UNIX, errno, "cvec_new()");	
	goto done;
    }   
    if (clicon_dbspec_parse_file(h, f, filename, pt, cvec) < 0)
	goto done;
    /* pick up name="myname"; from spec */
    if ((name = cvec_find_str(cvec, "name")) != NULL)
	clicon_dbspec_name_set(h, name);
    retval = 0;
  done:
    if (cvec)
	cvec_free(cvec);
    if (f)
	fclose(f);
    return retval;
}


/* called on exit */
int
db_spec_free(struct db_spec *db_spec_list)
{
    struct db_spec *db;

    while ((db = db_spec_list) != NULL){
	db_spec_list = db->ds_next;
	db_spec_free1(db);
    }
    return 0;
}

char *
db_spec2str(struct db_spec *db)
{
    char   *str;
    char   *retval = NULL;
    cvec   *vec;
    cg_var *cv;

    if ((str = chunk_sprintf(__FUNCTION__, "%s", db->ds_key)) == NULL)
	goto done;
    if ((vec = db_spec2cvec(db)) != NULL){
	cv = NULL;
	while ((cv = cvec_each(vec, cv))) {
	    if ((str = chunk_sprintf(__FUNCTION__, "%s $%s%s",  
				     str,
				     cv_flag(cv, V_UNIQUE)?"!":"",
				     cv_name_get(cv))) == NULL)
		goto done;
	}
    }
    retval = strdup(str);
  done:
    unchunk_group(__FUNCTION__);
    return retval;
    
}
/* 
 * db_spec_dump
 * debug, should be equiv to db_spec_file.txt 
 */
int
db_spec_dump(FILE *f, struct db_spec *dbl)
{
    struct db_spec *db;
    char           *str;
    int             retval = -1;

    for (db=dbl; db; db=db->ds_next){
	if ((str = db_spec2str(db)) == NULL)
	    goto done;
	fprintf(f, "%s", str);
	free(str);
#ifdef obsolete
	fprintf(f, "%s", db->ds_key);
	if ((vec = db_spec2cvec(db)) != NULL){
	    cv = NULL;
	    while ((cv = cvec_each(vec, cv))) {
		fprintf(f, " $%s%s:%s",  
			cv_flag(cv, V_UNIQUE)?"!":"",
			cv_name_get(cv),
			cv_type2str(cv_type_get(cv))
		    );
		if (!cv_flag(cv, V_UNSET)){
		    fprintf(f, "=");
		    cv_print(f, cv);
		}
	    }
	}
#endif
	fprintf(f, " \n");
    }
    retval = 0;
  done:
    return retval;
}

/*
 * spec_key_index
 * eat numerical tokens from key.
 * key is expected to be on the form '123.a.b', eat until '.a.b'
 */
static int
match_key_index(int *i0, char *key)
{
    int i = *i0;

    while (isdigit(key[i]))
	i++;
    if (i == *i0)
	return 0; /* fail */
    i--;
    *i0 = i;
    return 1;
}

/*
 * match_key
 * key on the form A.4.B.4
 * skey on the form A[]B[]
 * return 0 on fail, 1 on sucess.
 * key:  a.0b
 * skey: a[]
 */
int
match_key(char *key, char *skey)
{
    int   i, j;
    char  k, s;
    int   vec;
    
    vec = 0;
    for (i=0, j=0; i<strlen(key) && j<strlen(skey); i++, j++){
	k = key[i];
	s = skey[j];
	if (vec){
	    vec = 0;
	    if (s == ']') /* skey has [] entry */
		if (match_key_index(&i, key) == 1)
		    continue; /* ok */
	    break; /* fail */
	}
	else{
	    if (s == '[' && k == '.')
		vec++;
	    else
		if (k != s)
		    break; /* fail */
	}
    } /* for */
    if (i>=strlen(key) && j>=strlen(skey) && vec==0)
	return 1; /* ok */
    else
	return 0; /* fail */
}

/*
 * key2spec_key
 * Get db_spec struct
 * given a specific key, find a matching specification, (dbsepc key-style)
 * e.g. a.0 matches the db_spec corresponding to a[].
 * Input args:
 *  dbspec_list - db specification as list of keys
 *  key - key to find in dbspec
 */
struct db_spec *
key2spec_key(struct db_spec *dbspec_list, char *key)
{
    struct db_spec *db;
    int             ret;

    for (db=dbspec_list; db; db=db->ds_next){
	if ((ret = match_key(key, db->ds_key)) < 0)
	    goto catch;
	if (ret)
	    break;
    } /* for */
    return db; // db_spec2vh(db);
  catch:
    return NULL;
}

static struct cg_obj *
key2spec_co1(parse_tree *pt, char **vec, int nvec)
{
    char            *key;
//    char            *index;
    cg_obj          *co;
    int              i;

    if (nvec <= 0)
	return NULL;
    key = vec[0];
    for (i=0; i<pt->pt_len; i++){
	if ((co = pt->pt_vec[i]) == NULL)
	    continue;
	if (co->co_type != CO_COMMAND)
	    continue;
	if (strcmp(key, co->co_command) != 0)
	    continue;
	if (dbspec_indexvar_get(co)){
	    nvec--;
	    if (nvec <= 0)
		return NULL;
//	    index = vec[0]; /* assume index is number */
	}
	if (nvec == 1)
	    return co;
	return key2spec_co1(&co->co_pt, vec+1, nvec-1);
    }
    return NULL;
}

/*
 * key2spec_co
 * given a specific key, find a matching specification (dbspec cli-object style).
 * e.g. a.0 matches the db_spec corresponding to a[].
 * Input args:
 *  pt - db specification parse-tree
 *  key - key to find in dbspec
 */
struct cg_obj *
key2spec_co(parse_tree *pt, char *key)
{
    char           **vec;
    int              nvec;

    if ((vec = clicon_strsplit(key, ".", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_DB, errno, "%s: strsplit", __FUNCTION__); 
	return NULL;
    }
    return key2spec_co1(pt, vec, nvec);
}


/*
 * Sanity check on key and its variable list vh
 * Check against the database that:
 * 1. the key exists, 
 * 2. each variable exists
 * 3. the type of each variable match
 * 4. flags (unique) of each variable match
 * Sanity errors are logged
 * spec is the db_spec associated with key (not dbspec list)
 */
int
sanity_check_cvec(char *key, struct db_spec *spec, cvec *vec)
{
    cvec *vecs;
    cg_var *cv, *cvs;
    char *vkey;
    int errs = 0;

    vecs = db_spec2cvec(spec);
    cv = NULL;
    while ((cv = cvec_each(vec, cv))) {		
	vkey = cv_name_get(cv);
	if (vkey[0]=='!')
	    vkey++;
	if ((cvs = cvec_find(vecs, vkey)) == NULL){
	    clicon_log(LOG_WARNING, "%s: %s $%s not found in database spec (spec key:%s)\n",
		       __FUNCTION__, key, vkey, spec->ds_key);
	    errs++;
	    continue;
	}
	if (cv_type_get(cv) != cv_type_get(cvs)) {
	    clicon_log(LOG_WARNING, "%s: %s $%s: type (%s) does not match spec (%s)\n",
		       __FUNCTION__, key, cv_name_get(cv), 
		       cv_type2str(cv_type_get(cv)),
		       cv_type2str(cv_type_get(cvs)));
	    errs++;
	}
	if (cv_flag(cv, V_UNIQUE) != cv_flag(cvs, V_UNIQUE)){
	    clicon_log(LOG_WARNING, "%s: %s $%s: flag (%d) does not match spec (%d)\n",
		       __FUNCTION__, key, cv_name_get(cv),
		       cv_flag(cv, V_UNIQUE), cv_flag(cvs, V_UNIQUE));
	    errs++;
	}
    }
    return 0; /* ignore errors */

}

/*---------------------------------------------------------------------------
 * key2cli code
 *--------------------------------------------------------------------------*/
/*
 * cogen_new
 * Translate db specification from a key to a cli format
 */
static cg_obj *
cogen_new(clicon_handle h, cg_obj *cop, char *key)
{
    cg_obj             *co;

    if ((co = co_new(key, cop)) == NULL) { 
	clicon_err(OE_UNIX, errno, "Allocating cligen object"); 
	goto err;
    }
    if (dbspec_userdata_add(h, co) < 0)
	goto err;
    if ((co = co_insert(&cop->co_pt, co)) == NULL)  {
	clicon_err(OE_UNIX, errno, "Inserting cligen object"); 
	goto err;
    }
//    co->co_nonterminal++;	
/* successively build string of key var* for insertion into cli_set() for example */
    return co;
  err:
    if (co)
	co_free(co, 1);
    return NULL;
}

/*
 * covar_new
 * Translate db specification from a key to a cli format
 * add new variable co under cop
 */
static cg_obj *
covar_new(clicon_handle h, cg_obj *cop, cg_var *v)
{
    cg_obj             *cov = NULL;

    if ((cov = co_new(cv_name_get(v), cop)) == NULL) { 
	clicon_err(OE_UNIX, errno, "Allocating cligen object"); 
	goto err;
    }
    cov->co_type = CO_VARIABLE;
    cov->co_vtype = cv_type_get(v);
    if (dbspec_userdata_add(h, cov) < 0)
	goto err;

    if (!cv_flag(v, V_UNSET))
	dbspec_default_set(cov, cv_dup(v)); /* Could actually get only .u part */

    if ((cov = co_insert(&cop->co_pt, cov)) == NULL)  {
	clicon_err(OE_UNIX, errno, "Inserting cligen object"); 
	goto err;
    }
    unchunk_group(__FUNCTION__);  
    return cov;
  err:
    if (cov)
	co_free(cov, 1);
    unchunk_group(__FUNCTION__);  
    return NULL;
}

/* 
 * dbspec_key2cli
 * Translate db specification from a key to a cli format
 * Input: 
 *    db_spec:   Database specification.
 *    pt         parse-tree
 */
int
dbspec_key2cli(clicon_handle h, struct db_spec *db_spec, parse_tree *pt)
{
    int              retval = -1;
    struct db_spec  *ds;
    char           **vec;
    char            *key;
    int              nvec;
    int              i;
    cvec            *subvh;
    cg_var          *v = NULL;
    cg_obj          *co;
    cg_obj          *cov;
    cg_obj           co0; /* tmp top object: NOT malloced */
    cg_obj          *cop; /* parent */
    int              isvec;
    char            *str;

    memset(&co0, 0, sizeof(co0));
    /* Parse through all spec lines */
    for (ds=db_spec; ds; ds=ds->ds_next){
	clicon_debug(2, "%s: spec line: %s\n", __FUNCTION__, ds->ds_key);
	subvh = db_spec2cvec(ds);
	v = NULL; 		
	co = NULL;
	if ((vec = clicon_strsplit(ds->ds_key, ".", &nvec, __FUNCTION__)) == NULL){
	    clicon_err(OE_DB, errno, "%s: strsplit", __FUNCTION__); 
	    goto catch;
	}
	cop = &co0;
	v = NULL; /* unique variable */
	/* Parse through all keys in a spec-line, eg "a.b.c" */
	for (i=0; i<nvec; i++){ 
	    key = vec[i];
	    clicon_debug(2, "%s: \tkey: %s\n", __FUNCTION__, vec[i]);
	    isvec = 0;
	    if (key_isvector(key)){
		isvec++;
		key[strlen(key)-2] = '\0';
	    }
	    /* check if key already exists in existing parse-tree */
	    if ((co = co_find_one(cop->co_pt, key)) == NULL){
		if ((co = cogen_new(h, cop, key)) == NULL){
		    goto catch;
		}
	    } /* co is key */
	    if (co->co_type != CO_COMMAND){
		clicon_err(OE_DB, 0, "%s: child '%s' in '%s' has mixed types\n",
			   __FUNCTION__, key, ds->ds_key); 
		goto catch;
	    }
	    if (isvec){ 
		/* Find unique key and add that as sub (if it does not already exist) */
		while ((v = cvec_each(subvh, v))) 
		    if (cv_flag(v, V_UNIQUE))
			break;
		if (v == NULL){
		    clicon_err(OE_DB, 0, "Spec has no matching unique variable\n"); 
		    goto catch;
		}
		/* A unique variable is created */
		if ((cov = co_find_one(co->co_pt, cv_name_get(v))) == NULL)
		    if ((cov = covar_new(h, co, v)) == NULL)
			goto catch;
//		co_insert(&cov->co_pt, NULL); /* empty child */
		if ((str = db_spec2str(ds)) == NULL)
		    goto catch;
		/* The unique variable is added as indexvar in co */
		if (dbspec_key_set(cov, str) < 0)
		    goto catch;
// XXX ??	dbspec_default_set(co, cv_dup(v));
	    }
	    cop = co;
	} /* Parse through all keys in a spec-line, eg "a.b.c[]" */

	/* Remaining unique variables are added at the end */
	while ((v = cvec_each(subvh, v))) {
	    if (!cv_flag(v, V_UNIQUE))
		continue;
	    /* A variable is created as '<name>' */
	    if ((cov = co_find_one(co->co_pt, cv_name_get(v))) == NULL)
		if ((cov = covar_new(h, co, v)) == NULL)
		    goto catch;
	    if ((str = db_spec2str(ds)) == NULL)
		goto catch;
	    /* The unique variable is added as indexvar in co */
	    if (dbspec_key_set(cov, str) < 0)
		goto catch;

	    co = cov;
	}

	/* Go through all non-unique variables and append to syntax */
	v = NULL;
	while ((v = cvec_each(subvh, v))) {
	    if (cv_flag(v, V_UNIQUE))
		continue;
	    if ((cov = covar_new(h, co, v)) == NULL)
		goto catch;
	    co_insert(&cov->co_pt, NULL); /* empty child */
		if ((str = db_spec2str(ds)) == NULL)
		    goto catch;
		/* The unique variable is added as indexvar in co */
		if (dbspec_key_set(cov, str) < 0)
		    goto catch;

	} /* while single var not unique */
    } /* for (ds): lines in database */

    /*
     * Remove the fake top level object and remove references to it.
     */
    *pt = co0.co_pt;
    for (i=0; i<co0.co_max; i++){
	co=co0.co_next[i];
	if (co)
	    co_up_set(co, NULL);
    }
    retval = 0;
  catch:
    /*
     * Remove the fake top level object and remove references to it.
     */
    for (i=0; i<co0.co_max; i++){
	co=co0.co_next[i];
	if (co)
	    co_up_set(co, NULL);
    }
    unchunk_group(__FUNCTION__);  
    return retval;
}

/*---------------------------------------------------------------------------
 * cli2key code
 *--------------------------------------------------------------------------*/
/*
 * Create a dbspeckey
 */
static int
cli2db_genkey(cvec *keys, cvec *vars, struct db_spec **dsp)
{
    char           *key = NULL;
    cg_var         *cv = NULL;
    struct db_spec *ds = NULL;

    while ((cv = cvec_each(keys, cv)) != NULL) 
	key = chunk_sprintf(__FUNCTION__, "%s%s%s%s",
			    key?key:"",
			    key?".":"",
			    cv_name_get(cv),
			    cv_flag(cv, V_UNIQUE)?"[]":"");
    if (key==NULL){
	*dsp = NULL;
	return 0;
    }
    if ((ds = db_spec_new()) == NULL) /* XXX */
	goto err;
    if ((ds->ds_key = strdup(key)) == NULL){
	clicon_err(OE_DB, errno, "%s: strdup", __FUNCTION__); 
	goto err;
    }
    if ((ds->ds_vec = cvec_dup(vars)) == NULL){
	clicon_err(OE_DB, errno, "%s: cvec_dup", __FUNCTION__); 
	goto err;
    }
    unchunk_group(__FUNCTION__);
    *dsp = ds;
    return 0;
  err:
    if (ds)
	db_spec_free(ds);
    unchunk_group(__FUNCTION__);
    return -1;
}

/* Forward */
static int
dbspec_cli2key_co(cg_obj          *co0,
		  cvec            *keys,   
		  cvec            *vars,   
		  struct db_spec **ds_list);

/*
 * dbspec_cli2key_co_addvar
 *
 * Add a new variable to the list of variables in vars, 
 * a key consists of 'key vars'.
 * Create a new key and append to ds_list
 */
static int
dbspec_cli2key_co_addvar(cg_obj          *co,
			 int              unique,
			 cvec            *keys0,  
		         cvec            *vars,
			 struct db_spec **ds_list)
{
    int             retval = -1;
    cg_var         *cv;
    struct db_spec *ds;
    char           *str;

    if ((cv = cvec_add(vars, co->co_vtype)) == NULL){
	clicon_err(OE_DB, errno, "%s: cvec_add", __FUNCTION__); 
	goto done;
    }
    if (dbspec_default_get(co)){ /* default value */
	if (cv_cp(cv, dbspec_default_get(co)) < 0){
	    clicon_err(OE_DB, errno, "%s: cv_cp", __FUNCTION__); 
	    goto done;
	}
    }
    else
	cv_flag_set(cv, V_UNSET);
    if (unique)
	cv_flag_set(cv, V_UNIQUE);
    if (cv_name_set(cv, co->co_command) == NULL) {
	clicon_err(OE_UNIX, errno, "cv_name_set"); 
	goto done;
    }
    if (cli2db_genkey(keys0, vars, &ds) < 0)
	goto done;
    if (ds==NULL){
	clicon_err(OE_DB, errno, "No ds created for %s", co->co_command); 
	goto done;
    }
    if (dbspec_vector_get(co))
	ds->ds_vector = 1;
    if ((str = db_spec2str(ds)) == NULL)
	goto done;
    if (dbspec_key_set(co, str) < 0)
	goto done;
    db_spec_tailadd(ds_list, ds); /* ds may be freed */

    retval = 0;
  done:  
    return retval;
}

/*
 * dbspec_cli2key_co_cmd
 */
static int
dbspec_cli2key_co_cmd(cg_obj          *co,
		      cvec            *keys0,   /* inherited keys */
		      cvec            *vars0,   /* inherited vars */
		      struct db_spec **ds_list)
{
    cg_var         *cv;
    int             i;
    parse_tree     *pt;
    parse_tree     *ptv;
    char           *indexvar = dbspec_indexvar_get(co);
    char           *str;
    cg_obj         *co1;
    cg_obj         *cov;
    cvec           *keys = NULL;
    cvec           *vars = NULL;
    int             retval = -1;
    struct db_spec *ds = NULL;

    pt = &co->co_pt;
    /* Append a key to dbspec for every command. Check if list or not */
    if ((cv = cvec_add(keys0, CGV_STRING)) == NULL){
	clicon_err(OE_DB, errno, "%s: cvec_add", __FUNCTION__); 
	goto done;
    }
    if (cv_name_set(cv, co->co_command) == NULL) {
	clicon_err(OE_UNIX, errno, "cv_name_set"); 
	goto done;
    }

    if (indexvar){
	/* This cmd has index variable, mark it as such (print as x[]) */
	cv_flag_set(cv, V_UNIQUE); 	
	/* This cmd has index variable. Loop thru children and find it */
	cov = NULL;
	for (i=0; i<pt->pt_len; i++){
	    cov = pt->pt_vec[i];
	    if (cov && 
		cov->co_type == CO_VARIABLE && 
		strcmp(indexvar, cov->co_command)==0){
		break;
	    }
	}
	if (i==pt->pt_len){
	    clicon_err(OE_DB, errno, "%s: %s has no indexvariable %s\n", 
		       __FUNCTION__, co->co_command, indexvar); 
	    goto done;
	}
	assert(cov);
	/* Sanity check: indexvar should not have children */
	ptv = &cov->co_pt;
	if (ptv->pt_len)
	    if (ptv->pt_len > 1 || ptv->pt_vec[0] != NULL){
		clicon_err(OE_DB, errno, "Variable %s has children, should be leaf", 
			   cov->co_command); 
		goto done;
	    }
	/* Add the index-variable to the list of variables in vars */
	if (dbspec_cli2key_co_addvar(cov, 1, keys0, vars0, ds_list) < 0)
	    goto done;
    }
    /* Add symbol to dbspec structure (used in callback) */
    if (cli2db_genkey(keys0, vars0, &ds) < 0)
	goto done;
    if (ds == NULL){
	clicon_err(OE_DB, errno, "No ds created for %s", co->co_command); 
	goto done;
    }
    if ((str = db_spec2str(ds)) == NULL)
	goto done;
    if (dbspec_key_set(co, str) < 0)
	goto done;
    db_spec_free1(ds);
    for (i=0; i<pt->pt_len; i++){
	if ((co1 = pt->pt_vec[i]) == NULL){
	    if (cli2db_genkey(keys0, vars0, &ds) < 0)
		goto done;
	    db_spec_tailadd(ds_list, ds); /* ds computed above */
	    continue;
	}
	/* index variables already handled */
	if (indexvar &&
	    co1->co_type == CO_VARIABLE && 
	    strcmp(indexvar, co1->co_command)== 0)
	    continue;
	if ((keys = cvec_dup(keys0)) == NULL){
	    clicon_err(OE_DB, errno, "%s: chunk", __FUNCTION__); 
	    goto done;
	}
	if ((vars = cvec_dup(vars0)) == NULL){
	    clicon_err(OE_DB, errno, "%s: cvec_dup", __FUNCTION__); 
	    goto done;
	}
	if (dbspec_cli2key_co(co1, keys, vars, ds_list) < 0)
	    goto done;
	cvec_free(vars);
	cvec_free(keys);
    }
    retval = 0;
  done:  /* note : no unchunk here: recursion */
    return retval;
}

/*
 * dbspec_cli2key_co_var
 */
static int
dbspec_cli2key_co_var(cg_obj          *co,
		      cvec            *keys0,   /* inherited keys (encoded as vars) */
		      cvec            *vars0,   /* inherited vars */
		      struct db_spec **ds_list)
{
    int             retval = -1;
    parse_tree     *pt;

    pt = &co->co_pt; /* Canonical form: <var> (leaf) should have no children. */
    if (pt->pt_len > 1 || pt->pt_vec[0] != NULL){
	clicon_err(OE_DB, errno, "Variable %s has children, should be leaf", 
		   co->co_command); 
	goto done;
    }
    /* Assume index variable already handled */
    if (dbspec_cli2key_co_addvar(co, 0, keys0, vars0, ds_list) < 0)
	goto done;

    retval = 0;
  done:  
    return retval;
}

/*
 * dbspec_cli2key_co
 * Translate cg_obj co0 to key dbspec.
 * There are four kinds, two for commands, two for variables:
 *  list      g[i]{<x>,a} ==> g[] $!i <x>; g[].a...
 *  container g{<x>,a>}   ==> g $x; g.a
 *  leaf      <x>         ==> $x
 *  leaf-ist  <x[]>       ==> $x[] NOTYET
 */
static int
dbspec_cli2key_co(cg_obj          *co,
		  cvec            *keys0,   /* inherited keys (encoded as vars) */
		  cvec            *vars0,   /* inherited vars */
		  struct db_spec **ds_list)

{
    int             retval = -1;

    assert(co->co_type == CO_COMMAND ||co->co_type == CO_VARIABLE);
    switch (co->co_type){
    case CO_COMMAND: /* Add command as key */
	if (dbspec_cli2key_co_cmd(co, keys0, vars0, ds_list) < 0)
	    goto done;
	break;
    case CO_VARIABLE: /* Add variable as value */
	if (dbspec_cli2key_co_var(co, keys0, vars0, ds_list) < 0)
	    goto done;
	break;
    default:
	break;
    }
    retval = 0;
  done:  /* note : no unchunk here: recursion */
    return retval;
}

/*
 * dbspec_cli2key
 * Translate a cli spec to a dbspec. 
 * Not completely trivial. some cases:
 * a <a>         --> a $a
 * a <!a>        --> a[] $a
 * a b <a>       --> a.b $a
 * a b <!a>      --> a.b[] $!a
 * a <!a> b <b>  --> a[]   $!a   # NOTE!
                     a[].b $!a $b
 * And of course:
 * a { b; c; }  --> a.b
 *                  a.c
 */
struct db_spec *
dbspec_cli2key(parse_tree *pt)
{
    int             i;
    cg_obj         *co;
    struct db_spec *ds_list = NULL; 
    cvec           *keys;
    cvec           *vars;

    for (i=0; i<pt->pt_len; i++){
	if ((co = pt->pt_vec[i]) == NULL)
	    continue;
	if ((vars = cvec_new(0)) == NULL){
	    clicon_err(OE_DB, errno, "%s: cvec_new", __FUNCTION__); 
	    goto err;
	}
	if ((keys = cvec_new(0)) == NULL){
	    clicon_err(OE_DB, errno, "%s: cvec_new", __FUNCTION__); 
	    goto err;
	}
	if (dbspec_cli2key_co(co, keys, vars, &ds_list) < 0)
	    goto err;
	cvec_free(vars);
	cvec_free(keys);
    }
    if (ds_list == NULL){
	clicon_err(OE_DB, errno, "%s: Empty database-spec", __FUNCTION__); 
	goto err;
    }
    return ds_list;
  err:
    if (ds_list)
	db_spec_free(ds_list);
    return NULL;
}

/*
 * Access macros for cligen_objects userdata
 */
char *
dbspec_indexvar_get(cg_obj *co)
{
    struct dbspec_userdata *du = (struct dbspec_userdata*)co->co_userdata;

    assert(du);
    return du->du_indexvar;
}

int 
dbspec_indexvar_set(cg_obj *co, char *val)
{
    struct dbspec_userdata *du = (struct dbspec_userdata*)co->co_userdata;

    assert(du);
    du->du_indexvar = val;
    return 0;
}

char *
dbspec_key_get(cg_obj *co)
{
    struct dbspec_userdata *du = (struct dbspec_userdata*)co->co_userdata;

    assert(du);
    return du->du_dbspec;
}

int 
dbspec_key_set(cg_obj *co, char *val)
{
    struct dbspec_userdata *du = (struct dbspec_userdata*)co->co_userdata;

    assert(du);
    du->du_dbspec = val;
    return 0;
}

int 
dbspec_optional_get(cg_obj *co)
{
    struct dbspec_userdata *du = (struct dbspec_userdata*)co->co_userdata;

    assert(du);
    return du->du_optional;
}

int 
dbspec_optional_set(cg_obj *co, int val)
{
    struct dbspec_userdata *du = (struct dbspec_userdata*)co->co_userdata;

    assert(du);
    du->du_optional = val;
    return 0;
}

struct cg_var *
dbspec_default_get(cg_obj *co)
{
    struct dbspec_userdata *du = (struct dbspec_userdata*)co->co_userdata;

    assert(du);
    return du->du_default;
}

int 
dbspec_default_set(cg_obj *co, struct cg_var *val)
{
    struct dbspec_userdata *du = (struct dbspec_userdata*)co->co_userdata;

    assert(du);
    du->du_default = val;
    return 0;
}

char 
dbspec_vector_get(cg_obj *co)
{
    struct dbspec_userdata *du = (struct dbspec_userdata*)co->co_userdata;

    assert(du);
    return du->du_vector;
}

int 
dbspec_vector_set(cg_obj *co, char val)
{
    struct dbspec_userdata *du = (struct dbspec_userdata*)co->co_userdata;

    assert(du);
    du->du_vector = val;
    return 0;
}

/* 
 * Add malloced piece of code to attach to cligen objects used as db-specs.
 * So if(when) we translate cg_obj to dbspec_obj (or something). These are the fields
 * we should add.
 */
int
dbspec_userdata_add(clicon_handle h, cg_obj *co)
{
    struct dbspec_userdata *du;

    if ((co->co_userdata  = malloc(sizeof (struct dbspec_userdata))) == NULL){
	clicon_err(OE_UNIX, errno, "malloc");
	return -1;
    }
    du = (struct dbspec_userdata *)co->co_userdata;
    memset(du, 0, sizeof (struct dbspec_userdata));
    du->du_optional = clicon_cli_genmodel_optional(h);
    return 0;
}

int
dbspec_userdata_delete(cg_obj *co, void *arg)
{
    struct dbspec_userdata *du = (struct dbspec_userdata *)co->co_userdata;

    if (du == NULL)
	return 0;
    if (du->du_indexvar)
	free(du->du_indexvar);
    if (du->du_dbspec)
	free(du->du_dbspec);
    if (du->du_default)
	cv_free(du->du_default);
    free(du);
    co->co_userdata = NULL;
    return 0;
}
