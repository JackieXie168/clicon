/*
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 * 
 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <stdarg.h>
#include <time.h>
#include <ctype.h>

#include <unistd.h>
#ifdef HAVE_CRYPT_H
#include <crypt.h>
#endif 
#include <dirent.h>
#include <syslog.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/param.h>
#include <sys/mount.h>
#include <pwd.h>
#include <assert.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

#include "clicon_cli_api.h"

#include "cli_common.h"


/*
 * init_candidate_db
 * There are several variants in Junos. We have implemented these:
 * private - every user has an own candidate db (last one commit wins)
 * shared - all users share a common candidate db
 * current - use current as candidate
 * exclusive - only one user can have a candidate (not implemented)
 */
int 
init_candidate_db(clicon_handle h, enum candidate_db_type type)
{
    int retval = -1;
    struct stat  sb;
    char *running_db; 
    char *candidate_db;
    char *s;

    if ((running_db = clicon_running_db(h)) == NULL){
    	clicon_err(OE_PLUGIN, 0, "%s: RUNNING_CANDIDATE_DB option not set", __FUNCTION__); 
	goto err;
    }
    if ((candidate_db = clicon_candidate_db(h)) == NULL){
    	clicon_err(OE_PLUGIN, 0, "%s: CLICON_CANDIDATE_DB option not set", __FUNCTION__); 
	goto err;
    }
    cli_set_candidate_type(h, type);
    switch(type){
    case CANDIDATE_DB_NONE:
	break;
    case CANDIDATE_DB_PRIVATE:
	if (lstat(candidate_db, &sb) < 0){
	    if (file_cp(running_db, candidate_db) < 0){
		clicon_err(OE_UNIX, errno, "Error when copying %s to %s: %s\n", 
			running_db, candidate_db,
			strerror(errno));
		unlink(candidate_db);
		goto err;
	    }
	}
	break;
    case CANDIDATE_DB_SHARED:
	if (lstat(candidate_db, &sb) < 0){
	    s = clicon_sock(h);
	    cli_proto_copy(s, running_db, candidate_db);
	}
	break;
    case CANDIDATE_DB_CURRENT:
	clicon_option_str_set(h, "CLICON_CANDIDATE_DB",  running_db);
	break;
    }
    retval = 0;
  err:
    return retval;
}

/*
 * exit_candidate_db
 * private canddidates should be removed
 */
int 
exit_candidate_db(clicon_handle h)
{
//    struct stat  sb;

    switch(cli_candidate_type(h)){
    case CANDIDATE_DB_PRIVATE:
#if 0 /* XXX: maybe we should remove it, but I want several cli:s to edit it */
	if (lstat(clicon_candidate_db(h), &sb) == 0)
	    unlink(clicon_candidate_db(h));
#endif
	break;
    default:
	break;
    }
    return 0;
}

/* 
 * CLI output callback. 
 * 'str' is already pre-formatted. Make sure we make "%%" out of all "%" 
 * before sending to cligen_output()
 */
void
cli_output_cb (char *str)
{
  int idx;
  int npcnt;
  char *new;
  char *newp;

  /* Count number of '%' to know how large the new string need to be */
  for (npcnt = idx = 0; str[idx]; idx++)
    if (str[idx] == '%')
      npcnt++;

  /* Allocate new string */
  new = malloc (strlen (str) + npcnt + 1);
  if (!new)
    new = str;

  /* Copy string to new string, doubling all '%' */
  newp = new;
  for (idx = 0; str[idx]; idx++) {
    if (str[idx] == '%')
      *newp++ = '%';
    *newp++ = str[idx];
  }
  *newp++ = '\0';

  cligen_output (stdout, new);
  fflush (stdout);

  free (new);
}

/* 
 * CLI output format callback. 
 * Format a string and send print to user.
 */
void 
cli_fmt_output_cb(char *fmt, ...)
{
  char *str;
  va_list ap;
  int len;

  va_start(ap, fmt);
  len = vsnprintf(NULL, 0, fmt, ap);
  va_end(ap);
  if (len <= 0 || (str = (char *)chunk(len+1, __FUNCTION__)) == NULL) {
    fprintf(stderr, "Error: Failed to allocate memory\n");
    return;
  }
  va_start(ap, fmt);
  vsnprintf(str, len+1, fmt, ap);
  str[len] = '\0';
  va_end(ap);

  cli_output_cb(str);
  unchunk_group(__FUNCTION__);
}

/*
 * Run external process command.
 */
int 
cli_run(clicon_handle h, cvec *vr, cg_var *arg)
{
    int   retval = -1;
    char *cmd = NULL;
    char *str;

    if (arg==NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    if ((cmd = cgv_fmt_string (vr, str)) == NULL)
	goto done;
    if ((retval = clicon_proc_run(cmd, cli_output_cb, 1)) < 0)
	goto done;
    retval = 0;
  done:
    if (cmd)
	free (cmd);
    return retval;
}




/*
 * Set multiple db values.
 * arg is a vector of args delimited by ';'
 */
int 
cli_mset(clicon_handle h, cvec *vars, cg_var *arg)
{
    char  **vec = NULL;
    int     i;
    int     nvec;
    int     retval = -1;
    cg_var *cv;
    char   *str = NULL;

    if (arg == NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    if ((vec = clicon_strsplit(str, ";", &nvec, __FUNCTION__)) == NULL){
	goto done;
    }
    for (i=0; i<nvec; i++){
	if ((cv = cv_new(CGV_STRING)) == NULL){
	    cligen_output(stderr, "Allocating cligen object: %s\n", strerror(errno)); 
	    goto done;
	}
	if (cv_parse(vec[i], cv) < 0) { 
	    cligen_output(stderr, "Failed to parse string to cgv\n");
	    goto done;
	}
	if (cli_set(h, vars, cv) < 0) {
	    cv_free(cv);
	    goto done;
	}
	cv_free(cv);
    }
    retval = 0;
 done:
  unchunk_group(__FUNCTION__) ;
  return retval;
}


/*
 * Merge multiple db values.
 * arg is a vector of args delimited by ';'
 */
int 
cli_mmerge(clicon_handle h, cvec *vars, cg_var *arg)
{
    char  **vec = NULL;
    int     i;
    int     nvec;
    int     retval = -1;
    cg_var *cv = NULL; 
    char   *str = NULL;

    if (arg == NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    if ((vec = clicon_strsplit(str, ";", &nvec, __FUNCTION__)) == NULL){
	goto done;
    }
    for (i=0; i<nvec; i++){
	if ((cv = cv_new(CGV_STRING)) == NULL){
	    cligen_output(stderr, "Allocating cligen object: %s\n", strerror(errno)); 
	    goto done;
	}
	if (cv_parse(vec[i], cv) < 0) { /* NULL */
	    cligen_output(stderr, "Failed to parse string to cgv\n");
	    goto done;
	} 
	if (cli_merge(h, vars, cv) < 0) {
	    goto done;
	}
	cv_free(cv);
    }
    retval = 0;
 done:
    if (cv)
	cv_free(cv);
  unchunk_group(__FUNCTION__) ;
  return retval;
}

/*
 * cli_del_tree - Delete tree of keys from database. Unique variables
 * in keys will be taken into account.
 *
 * 
 */
int
cli_del_tree(clicon_handle h, cvec *vars, cg_var *arg)
{
    int     retval = -1;
    char   *key;
    char   *ptr;
    char   *opcmd;
    cg_var *cv; 
    char   *str = NULL;

    if (arg == NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    key = chunkdup(str, strlen(str)+1, __FUNCTION__);
    if (key == NULL) {
	clicon_err(OE_UNIX, errno, "chunk");
	goto done;
    }
    for (ptr = key; !isspace(*ptr); ptr++)
	/* Do nothing */ ;
    *ptr++ = '\0';

    /* First remove all child keys */
    if ((opcmd = chunk_sprintf(__FUNCTION__, "^%s..*$ %s", key, ptr)) == NULL) {
	clicon_err(OE_UNIX, errno, "chunk");
	goto done;
    }

    if ((cv = cv_new(CGV_STRING)) == NULL){
	clicon_err(OE_UNIX, errno, "Allocating cligen object"); 
	goto done;
    }
    if(cv_parse(opcmd, cv) < 0) { 
	clicon_err(OE_CFG, errno, "cv_parse");
	cv_free(cv);
	goto done;
    }
    retval = cli_del(h, vars, cv);
    cv_free(cv);
   
    if (retval >= 0)
	retval = cli_del(h, vars, arg);
    
done:
    unchunk_group(__FUNCTION__);

    return retval;
}


/*
 * View db contents based on lvmap.
 */
int
cli_show_lvmap(char *dbname, struct lvmap *lmap)
{
  int res = -1;
  FILE *f = NULL;
  char buf[1024];

  if ((f = tmpfile()) == NULL) {
    clicon_err(OE_UNDEF, errno, "tmpfile: %s", strerror (errno));
    return -1;
  }
  
  if (lvmap_print(f, dbname, lmap, NULL) < 0)
    goto done;

  /* Now send contents of file to cligen_output via cli_output_cb() */
  rewind(f);
  while(fgets(buf, sizeof(buf), f))
    cli_output_cb(buf);
  
  res = 0;

 done:
  if (f)
    fclose(f);
  return res;
}

/*
 * cli_debug
 * set debug level on stderr (not syslog).
 * The level is either what is specified in arg as int argument.
 * _or_ if a 'level' variable is present in vars use that value instead.
 */
int
cli_debug(clicon_handle h, cvec *vars, cg_var *arg)
{
    cg_var *cv;
    int     level;
    char   *s;

    if ((cv = cvec_find_var(vars, "level")) == NULL)
	cv = arg;
    level = cv_int32_get(cv);
    /* cli */
    clicon_debug_init(level, NULL); /* 0: dont debug, 1:debug */
    /* config daemon */
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (cli_proto_debug(s, level) < 0)
	goto done;
  done:
    return 0;
}


void
cli_signal_block(void)
{
	clicon_signal_block (SIGTSTP);
	clicon_signal_block (SIGQUIT);
	clicon_signal_block (SIGCHLD);
	clicon_signal_block (SIGINT);
}

void
cli_signal_unblock(void)
{
	clicon_signal_unblock (SIGTSTP);
	clicon_signal_unblock (SIGQUIT);
	clicon_signal_unblock (SIGCHLD);
	clicon_signal_unblock (SIGINT);
}

/*
 * Flush pending signals for a given signal type
 */
void
cli_signal_flush()
{
    /* XXX A bit rough. Use sigpending() and more clever logic ?? */

    sigfn_t   h1, h2, h3, h4;

    set_signal (SIGTSTP, SIG_IGN, &h1);
    set_signal (SIGQUIT, SIG_IGN, &h2);
    set_signal (SIGCHLD, SIG_IGN, &h3);
    set_signal (SIGINT, SIG_IGN, &h4);

    cli_signal_unblock ();

    set_signal (SIGTSTP, h1, NULL);
    set_signal (SIGQUIT, h2, NULL);
    set_signal (SIGCHLD, h3, NULL);
    set_signal (SIGINT, h4, NULL);

    cli_signal_block ();
}


/* Code for recording which CLI commands have been issued */

static FILE *_recordf = NULL;
static int _isrecording = 0;

int
isrecording(void)
{
    return _isrecording;
}

int
cli_record(clicon_handle h, cvec *vars, cg_var *arg)
{
    _isrecording = cv_int32_get(arg);
    return 0;
}

static int
record_open(void)
{
    char file[] = "/tmp/cli.record.XXXXXX";
    int fd;

    if ((fd = mkstemp(file)) < 0 || (_recordf = fdopen(fd, "w")) < 0) {
	clicon_err(OE_UNIX, errno, "mkstemp/fdopen");
	return -1;
    }
    return 0;
}

/*
 * record commands in file
 */
int
record_command(char *str)
{
    if (_recordf==NULL)
	if (record_open() < 0)
	    return -1;
    fprintf(_recordf, "%s\n", str);
    fflush(_recordf);
    return 0;
}


/*
 * Callback to set syntax mode
 */
int
cli_set_mode(clicon_handle h, cvec *vars, cg_var *arg)
{
    int     retval = -1;
    char   *str = NULL;

    if (arg == NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    cli_set_syntax_mode(h, str);
    retval = 0;
  done:
    return retval;
}

/*
 * XXX Application specific??
 * cli_start_shell
 * Start bash from cli callback
 */ 
int
cli_start_shell(clicon_handle h, cvec *vars, cg_var *arg)
{
    char *cmd;
    struct passwd *pw;
    int retval;
    char bcmd[128];
    cg_var *cv1 = cvec_i(vars, 1);

    cmd = (cvec_len(vars)>1 ? cv_string_get(cv1) : NULL);

    if ((pw = getpwuid(getuid())) == NULL){
	fprintf(stderr, "%s: getpwuid: %s\n", 
		__FUNCTION__, strerror(errno));
	return -1;
    }
    if (chdir(pw->pw_dir) < 0){ 
	fprintf(stderr, "%s: chdir(%s): %s\n",
		__FUNCTION__, pw->pw_dir, strerror(errno));
	endpwent();
	return -1;
    }
    endpwent();
    cli_signal_flush();
    cli_signal_unblock();
    if (cmd){
	snprintf(bcmd, 128, "bash -l -c \"%s\"", cmd);
	if ((retval = system(bcmd)) < 0){
	    cli_signal_block();
	    fprintf(stderr, "%s: system(bash -c): %s\n", 
		    __FUNCTION__, strerror(errno));
	    return -1;
	}
    }
    else
	if ((retval = system("bash -l")) < 0){
	    cli_signal_block();
	    fprintf(stderr, "%s: system(bash): %s\n", 
		    __FUNCTION__, strerror(errno));
	    return -1;
	}
    cli_signal_block();
#if 0 /* Allow errcodes from bash */
    if (retval != 0){
	fprintf(stderr, "%s: system(%s) code=%d\n", __FUNCTION__, cmd, retval);
      return -1;
    }
#endif

    return 0;
}

/*
 * Generic quit callback
 */
int 
cli_quit(clicon_handle h, cvec *vars, cg_var *arg)
{
    cli_set_exiting(h, 1);
    return 0;
}

/*
 * Generic commit callback
 * if arg is 1, then snapshot and copy to startup config
 */
int
cli_commit(clicon_handle h, cvec *vars, cg_var *arg)
{
    int            retval = -1;
    char          *s;
    int            snapshot = arg?cv_int32_get(arg):0;
    char          *candidate;
    char          *running;

    if ((running = clicon_running_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "running db not set");
	goto done;
    }
    if ((candidate = clicon_candidate_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "candidate db not set");
	goto done;
    }

    if ((s = clicon_sock(h)) == NULL){
	clicon_err(OE_FATAL, 0, "CLICON_SOCK option not set");
	goto done;
    }
    if ((retval = cli_proto_commit(s, 
				   running, 
				   candidate, 
				   snapshot, /* snapshot */
				   snapshot)) < 0){ /* startup */
	cli_output(stderr, "Commit failed. Edit and try again or discard changes\n");
	goto done;
    }
    retval = 0;
  done:
    return retval;
}

/*
 * Generic validatecallback
 */
int
cli_validate(clicon_handle h, cvec *vars, cg_var *arg)
{
    char          *s;
    char          *candidate_db;
    int            retval = -1;

    if ((s = clicon_sock(h)) == NULL)
	return -1;
    if ((candidate_db = clicon_candidate_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "candidate db not set");
	return -1;
    }
    if ((retval = cli_proto_validate(s, candidate_db)) < 0)
	cli_output(stderr, "Validate failed. Edit and try again or discard changes\n");
    return retval;
}


/*! Expand based on database key and variable value (of that key)
 *
 * Return an expand-type list of commands as used by cligen 'expand' 
 * functionality.
 * arg is a string: "<dbname> <keypattern> <variable>". 
 *   <dbname> is either running or candidate
 *   <keypattern> matches a set of database keys
 *   <variable>   is name of a variable occuring in the cli command string
 * Example: "candidate ^Create.*$" GroupName"
 * (See also expand_db_variable(). But this is more generic and can be called
 * as cligen callback)
 *
 * Assume callback given in a cligen spec: a <x:int expand_dbvar_auto("arg")
 * @param[in]   h        clicon handle 
 * @param[in]   name     Name of this function (eg "expand_dbvar")
 * @param[in]   vars     The command so far. Eg: cvec [0]:"a 5 b"; [1]: x=5;
 * @param[in]   arg      Argument given at the callback ("arg")
 * @param[out]  nr       len of return commands & helptxt 
 * @param[out]  commands vector of function pointers to callback functions
 * @param[out]  helptexts vector of pointers to helptexts
 */
int
expand_dbvar(void *h, char *name, cvec *vars, cg_var *arg, 
	     int *nr, char ***commands, char ***helptexts)
{
    char  *dbname;
    int    nvec;
    char **vec = NULL;
    int    retval = -1;
    char  *str;
    char  *dbstr, *keystr, *varstr;  

    if (arg == NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    if ((vec = clicon_strsplit(cv_string_get(arg), " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto done;
    }
    if (nvec != 3){
	clicon_err(OE_PLUGIN, 0, "format error \"%s\" - expected <dbname> <key> <variable>",
	    str);	
	goto done;
    }
    dbstr  = vec[0];
    keystr = vec[1];
    varstr = vec[2];
    if (strcmp(dbstr, "running") == 0) 
	dbname = clicon_running_db(h);
    else
    if (strcmp(dbstr, "candidate") == 0) 
	dbname = clicon_candidate_db(h);
    else{
	clicon_err(OE_PLUGIN, 0, "No such db name: %s", dbstr);	
	goto done;
    }
    if (dbname == NULL){
	clicon_err(OE_FATAL, 0, "dbname not set");
	goto done;
    }
    if ((retval = expand_db_variable(h, dbname, keystr, varstr, nr, commands)) < 0)
	goto done;
    retval = 0;
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}


/*! Completion callback primarily intended for automatically generated data model
 *
 * Returns an expand-type list of commands as used by cligen 'expand' 
 * functionality.
 * arg is a string: "<dbname> <keypattern> <variable>". 
 *   <dbname> is either running or candidate
 *   <pattern> matches a set of database keys following clicon_dbspec. 
 *             Eg a[].b[] $!x $!y
 *             the last being the variable to expand for.
 * Example:
 * dbspec is a[].b[] $!x $!y
 * clispec is a <x> b (<y>|<y expand_dbvar_auto()>;
 * db contains entries:
 * a.0 $x=5
 * a.1 $x=10
 * a.0.b.0 $x=5 $y=12
 * a.0.b.1 $x=5 $y=20
 * a.1.b.0 $x=10 $y=99
 *
 * The user types a 5 b <?> which produces the following output:
 *   <int>
 *   12
 *   20
 *
 * Assume callback given in a cligen spec: a <x:int expand_dbvar_auto("arg")
 * IN:
 *   h        clicon handle 
 *   name     Name of this function (eg "expand_dbvar-auto")
 *   cvec     The command so far. Eg: cvec [0]:"a 5 b"; [1]: x=5;
 *   arg      Argument given at the callback ("arg")
 * OUT:
 *   len      len of return commands & helptxt 
 *   commands vector of function pointers to callback functions
 *   helptxt  vector of pointers to helptexts
 */
int
expand_dbvar_auto(void *h, char *name, cvec *cvec, cg_var *arg, 
		  int *nr, char ***commands, char ***helptexts)
{
    char            *dbname;
    int              nvec;
    char           **vec = NULL;
    int              retval = -1;
    char            *str;
    char            *dbstr;  
    char            *rest;
    char            *last;
    dbspec_key  *spec;
    clicon_dbvars_t *dbv = NULL;
    cg_var          *cv;

    if (arg == NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    /* In the example, str = "candidate a[].b[] $!x $!y" */
    if ((vec = clicon_strsplit(cv_string_get(arg), " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto done;
    }
    dbstr  = vec[0];
    if (strcmp(dbstr, "running") == 0) 
	dbname = clicon_running_db(h);
    else
    if (strcmp(dbstr, "candidate") == 0) 
	dbname = clicon_candidate_db(h);
    else{
	clicon_err(OE_PLUGIN, 0, "No such db name: %s", dbstr);	
	goto done;
    }
    if (dbname == NULL){
	clicon_err(OE_FATAL, 0, "db not set");
	goto done;
    }

    spec = clicon_dbspec_key(h);
    /* rest is just arg stripped of <db>. Eg "a[].b[] $!x $!y"*/
    if ((rest = index(str, ' ')) == NULL)
	goto done;
    rest++;
    /* last is the last variable in arg. Eg "y" */
    if ((last = rindex(str, ' ')) == NULL)
	goto done;
    last++;
    if (index(last, '$'))
	last++;
    if (index(last, '!'))
	last++;

    /* For the cli_se_parse() function to work, we need to add the 'last' variable
       Eg: cvec [0]:"a 5 b"; [1]: x=5; [2]: y=0;
       (Not significant the type and value of last.
     */
    if ((cv = cvec_add(cvec, CGV_INT32)) == NULL) /* type not significant */
	goto done;
    cv_name_set(cv, last);
    cv_const_set(cv, 0);
    cv_int32_set(cv, 0); /* not significant */

    /* Parse the arg(rest). Get back a key (eg a.0.b[]) and vec (eg !x=5) */
    if ((dbv = cli_set_parse(h, 
			spec, 
			dbname, 
			cvec,
			     rest)) == NULL)
	goto done;
    cv = cvec_i(cvec, cvec_len(cvec)-1);
    cv_reset(cv);
    cvec_del(cvec, cv);
    if (debug > 1){
	fprintf(stderr, "%s: dbv_key: %s\n", __FUNCTION__, dbv->dbv_key);
	fprintf(stderr, "dbv_vec:");
	cvec_print(stdout, dbv->dbv_vec);
    }
    /* Look up in database and return available commands (eg "12,20") */
    if ((retval = expand_db_variable(h, dbname, dbv->dbv_key, 
				     last, 
				     nr, commands)) < 0)
	goto done;
    retval = 0;
  done:

    unchunk_group(__FUNCTION__);
    if (dbv)
	clicon_dbvars_free(dbv);

    return retval;

}

/*
 * expand_db_variable
 * Given a database, a basekey (pattern) and a variable, return an expand-type
 * list of commands as used by cligen 'expand' functionality.
 * (See also expand_dbvar())
 */
int
expand_db_variable(clicon_handle h, 
		   char         *dbname,
		   char         *basekey, 
		   char         *variable, 
		   int          *nr, 
		   char       ***commands)
{
    char           *key;
    int             i;
    int             retval = -1;
    int             npairs;
    struct db_pair *pairs;
    cvec           *cvec;
    cg_var         *cv = NULL;
    char          **tmp;
    char           *buf = NULL;
    char           *k;

    /* adhoc to detect regexp keys. If so, dont call db_gen_rxkey */
    if (index(basekey, '^') == NULL){
	if ((key = db_gen_rxkey(basekey, __FUNCTION__)) == NULL)
	    goto quit;
    }
    else
	key = chunkdup(basekey, strlen(basekey)+1, __FUNCTION__);
    
    npairs = db_regexp(dbname, key, __FUNCTION__, &pairs, 1);
    if (npairs < 0)
	goto quit;
    *nr = 0;
    for (i = 0; i < npairs; i++) {
	k = pairs[i].dp_key;
	if(key_isvector_n(k) || key_iskeycontent(k))
	    continue;
	if ((cvec = dbkey2cvec(dbname, pairs[i].dp_key)) == NULL)
	    goto quit;
	cv = NULL;
	while ((cv = cvec_each(cvec, cv)) != NULL) {
	    if (strcmp(cv_name_get(cv), variable) != 0)
		continue;
	    if ((buf = cv2str_dup(cv)) == NULL)
		goto quit;
	    if ((tmp = realloc(*commands, sizeof(char *) * ((*nr)+1))) == NULL) {
		clicon_err(OE_UNDEF, errno, "realloc: %s", strerror (errno));	
		goto quit;
	    }
	    *commands = tmp;
	    (*commands)[*nr] = buf;
	    buf = NULL;
	    (*nr)++;
	}
	cvec_free(cvec);
    }
    retval = 0;
quit:
    unchunk_group(__FUNCTION__);
    return retval;
}


/*
 * expand_db_symbol
 * pattern match in candidate_db
 */
int
expand_db_symbol(clicon_handle h, 
		 char *symbol, 
		 int element, 
		 int *nr, 
		 char ***commands)
{
    char          **tmp;
    struct db_pair *pairs;
    int             npairs;
    int             p;
    int             nvec;
    int             n;
    char          **vec = NULL;
    char            str[128];
    char           *dbname;
    
    if ((dbname = clicon_running_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "running db not set");
	goto done;
    }
    snprintf(str, sizeof(str), "^%s\\..", symbol);
    if ((npairs = db_regexp(dbname, str, __FUNCTION__, &pairs, 0)) < 0)
	return -1;
    for (p=0; p<npairs; p++){
	if ((vec = clicon_strsplit(pairs[p].dp_key, ".", &nvec, __FUNCTION__)) == NULL){
	    clicon_err(OE_UNDEF, errno, "clicon_strsplit");	
	    goto done;
	}
	/* Check if already exists */
	for (n=0; n<*nr; n++)
	    if (strcmp((*commands)[n], vec[element]) == 0)
		break; /* Already exists */
	if (n<*nr)
	    continue;
	/* Allocate new pointer */
	if ((tmp = realloc(*commands, sizeof(char *) * ((*nr)+1))) == NULL) {
	    clicon_err(OE_UNDEF, errno, "realloc: %s", strerror (errno));	
	    goto done;
	}
	*commands = tmp;
	/* Duplicate string */
	if (((*commands)[*nr] = strdup(vec[element])) == NULL) {
	    clicon_err(OE_UNDEF, errno, "strdup: %s", strerror (errno));	
	    goto done;
	}
	(*nr)++;
    }
    unchunk_group(__FUNCTION__) ;
    return 0;
 done:
  unchunk_group(__FUNCTION__) ;
  while ((*nr) >= 0)
    free((*commands)[(*nr)--]);
  free (*commands);
  return -1;
}

/*
 * expand_dir
 * List files in a directory
 */
int
expand_dir(char *dir, int *nr, char ***commands, mode_t flags, int detail)
{
    DIR	*dirp;
    struct dirent *dp;
    struct stat st;
    char *str;
    char *cmd;
    int len;
    int retval = -1;
    struct passwd *pw;
    char filename[MAXPATHLEN];

    if ((dirp = opendir(dir)) == 0){
	fprintf(stderr, "expand_dir: opendir(%s) %s\n", 
		dir, strerror(errno));
	return -1;
    }
    *nr = 0;
    while ((dp = readdir(dirp)) != NULL) {
	if (
#if 0
	    strcmp(dp->d_name, ".") != 0 &&
	    strcmp(dp->d_name, "..") != 0
#else
	    dp->d_name[0] != '.'
#endif	    
	    ) {
	    snprintf(filename, MAXPATHLEN-1, "%s/%s", dir, dp->d_name);
	    if (lstat(filename, &st) == 0){
		if ((st.st_mode & flags) == 0)
		    continue;

#if EXPAND_RECURSIVE
		if (S_ISDIR(st.st_mode)) {
		    int nrsav = *nr;
		    if(expand_dir(filename, nr, commands, detail) < 0)
			goto quit;
		    while(nrsav < *nr) {
			len = strlen(dp->d_name) +  strlen((*commands)[nrsav]) + 2;
			if((str = malloc(len)) == NULL) {
			    fprintf(stderr, "expand_dir: malloc: %s\n",
				    strerror(errno));
			    goto quit;
			}
			snprintf(str, len-1, "%s/%s",
				 dp->d_name, (*commands)[nrsav]);
			free((*commands)[nrsav]);
			(*commands)[nrsav] = str;
			
			nrsav++;
		    }
		    continue;
		}
#endif
		if ((cmd = strdup(dp->d_name)) == NULL) {
		    fprintf(stderr, "expand_dir: strdup: %s\n",
			    strerror(errno));
		    goto quit;
		}
		if (0 &&detail){
		    if ((pw = getpwuid(st.st_uid)) == NULL){
			fprintf(stderr, "expand_dir: getpwuid(%d): %s\n",
				st.st_uid, strerror(errno));
			goto quit;
		    }
		    len = strlen(cmd) + 
			strlen(pw->pw_name) +
#ifdef __FreeBSD__
			strlen(ctime(&st.st_mtimespec.tv_sec)) +
#else
			strlen(ctime(&st.st_mtim.tv_sec)) +
#endif

			strlen("{ by }") + 1 /* \0 */;
		    if ((str=realloc(cmd, strlen(cmd)+len)) == NULL) {
			fprintf(stderr, "expand_dir: malloc: %s\n",
				strerror(errno));
			goto quit;
		    }
		    snprintf(str + strlen(dp->d_name), 
			     len - strlen(dp->d_name),
			     "{%s by %s}",
#ifdef __FreeBSD__
			     ctime(&st.st_mtimespec.tv_sec),
#else
			     ctime(&st.st_mtim.tv_sec),
#endif

			     pw->pw_name
			);
		    cmd = str;
		}
		if (((*commands) =
		     realloc(*commands, ((*nr)+1)*sizeof(char**))) == NULL){
		    perror("expand_dir: realloc");
		    goto quit;
		}
		(*commands)[(*nr)] = cmd;
		(*nr)++;
		if (*nr >= 128) /* Limit number of options */
		    break;
	    }
	}
	
    }

    retval = 0;
  quit:
    closedir(dirp);
    return retval;
}


/*
 * Compare two dbs using XML
 */
static int
compare_xmls(cxobj *xc1, cxobj *xc2, int astext)
{
    int fd;
    FILE *f;
    char filename1[MAXPATHLEN];
    char filename2[MAXPATHLEN];
    char cmd[MAXPATHLEN];
    int retval = -1;
    cxobj *xc;

    snprintf(filename1, sizeof(filename1), "/tmp/cliconXXXXXX");
    snprintf(filename2, sizeof(filename2), "/tmp/cliconXXXXXX");
    if ((fd = mkstemp(filename1)) < 0){
	clicon_err(OE_UNDEF, errno, "tmpfile: %s", strerror (errno));
	goto done;
    }
    if ((f = fdopen(fd, "w")) == NULL)
	goto done;
    xc = NULL;
    if (astext)
	while ((xc = xml_child_each(xc1, xc, -1)) != NULL)
	    xml2txt(f, xc, 0);
    else
	while ((xc = xml_child_each(xc1, xc, -1)) != NULL)
	    clicon_xml2file(f, xc, 0, 1);

    fclose(f);
    close(fd);

    if ((fd = mkstemp(filename2)) < 0){
	clicon_err(OE_UNDEF, errno, "tmpfile: %s", strerror (errno));
	goto done;
    }
    if ((f = fdopen(fd, "w")) == NULL)
	goto done;
    xc = NULL;
    if (astext)
	while ((xc = xml_child_each(xc2, xc, -1)) != NULL)
	    xml2txt(f, xc, 0);
    else
	while ((xc = xml_child_each(xc2, xc, -1)) != NULL)
	    clicon_xml2file(f, xc, 0, 1);
    fclose(f);
    close(fd);

    snprintf(cmd, sizeof(cmd), "/usr/bin/diff -dU 1 %s %s |  grep -v @@ | sed 1,2d", 		 filename1, filename2);
    if (system(cmd) < 0)
	goto done;

    retval = 0;
  done:
    unlink(filename1);
    unlink(filename2);
    return retval;
}

/*
 * compare_dbs
 * using XML
 * arg: 0 as xml, 1: as xml
 */
int
compare_dbs(clicon_handle h, cvec *vars, cg_var *arg)
{
    cxobj *xc1 = NULL; /* running xml */
    cxobj *xc2 = NULL; /* candidate xml */
    int    retval = -1;
    char  *running;
    char  *candidate;

    if ((running = clicon_running_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "running db not set");
	goto done;
    }
    if ((candidate = clicon_candidate_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "candidate db not set");
	goto done;
    }
    if ((xc1 = db2xml(running, clicon_dbspec_key(h), "dbr")) == NULL)
	goto done;
    if ((xc2 = db2xml(candidate, clicon_dbspec_key(h), "dbc")) == NULL)
	goto done;

    if (compare_xmls(xc1, xc2, arg?cv_int32_get(arg):0) < 0) /* astext? */
	goto done;
    retval = 0;
  done:
    if (xc1)
	xml_free(xc1);    
    if (xc2)
	xml_free(xc2);

    return retval;
}


/*
 * cli_show_diff
 * Display the differences between two databases based on an
 * application specified lvmap.
 */
int
cli_show_diff(clicon_handle h, char *db1, char *db2, struct lvmap *lmap)
{
    int ret;
    int  retval = -1;
    char *cmd;
    char *tmp1 = NULL;
    char *tmp2 = NULL;
    FILE *f1 = NULL;
    FILE *f2 = NULL;

    /* dump db1 to file */
    if ((tmp1 = clicon_tmpfile(__FUNCTION__)) == NULL)
	goto quit;
    if ((f1 = fopen(tmp1, "w")) == NULL){
	clicon_err(OE_UNIX, errno, "fopen");
	goto quit;
    }
    ret = lvmap_print(f1, db1, lmap, NULL);
    fclose(f1);
    if (ret < 0)
	goto quit;

    /* dump db2 to file */
    if ((tmp2 = clicon_tmpfile(__FUNCTION__)) == NULL)
	goto quit;
    if ((f2 = fopen(tmp2, "w")) == NULL){
	clicon_err(OE_UNIX, errno, "fopen");
	goto quit;
    }
    ret = lvmap_print(f2, db2, lmap, NULL);
    fclose(f2);
    if (ret < 0)
	goto quit;

    /* diff candidate with snapshot */
    cmd = chunk_sprintf(__FUNCTION__,
			"/usr/bin/diff -dU 1 %s %s | grep -v @@ | sed 1,2d", 
			tmp1, tmp2);
    if (cmd == NULL) {
	clicon_err(OE_UNIX, errno, "chunk");
	goto quit;
    }
    if (system(cmd) < 0)
	goto quit;
    
    retval = 0;
quit:
    
    if (tmp1)
	unlink(tmp1);
    if (tmp2)
	unlink(tmp2);
    unchunk_group(__FUNCTION__);
    return retval;
}


/*! An rpc call from a frontend module to a function in a backend module
 *
 * A CLI/netconf frontend module can make a functional call to a backend
 * module and get return value back. 
 * The backend module needs to be specified (XXX would be nice to avoid this)
 * parameters can be sent, and value returned.
 * A function (func) must be defined in the backend module (plugin)
 * An example signature of such a downcall function is:
 * @code
int
downcall(clicon_handle h, uint16_t op, uint16_t len, void *arg, 
	      uint16_t *reply_data_len, void **reply_data)
 * @endcode
 *
 * @param[in]   h
 * @param[in]   op       Generic application-defined operation
 * @param[in]   plugin   Name of backend plugin (XXX look in backend plugin dir)
 * @param[in]   func     Name of function i backend (ie downcall above) as string
 * @param[in]   param    Input parameter given to function (void* arg in downcall)
 * @param[in]   paramlen Length of input parameter
 * @param[out]  ret      Returned data as byte-string. Deallocate w unchunk...(..., label)
 * @param[out]  retlen   Length of returned data
 * @param[in]   label    Label used in chunk (de)allocation.
 */
int
cli_downcall(clicon_handle h, uint16_t op, char *plugin, char *func,
	     void *param, uint16_t paramlen, 
	     char **ret, uint16_t *retlen,
	     const void *label
    )
{
    struct clicon_msg *msg;
    char *s;
    int retval = -1;

    if ((msg = clicon_msg_call_encode(op, plugin, func, 
				      paramlen, param, 
				      label)) == NULL)
	goto done;
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (clicon_rpc_connect(msg, s, (char**)ret, retlen, label) < 0)
	goto done;
    retval = 0;
done:
    return retval;
}


/* New cli_set/del code */
static int 
cli_dbop(clicon_handle h, cvec *vars, cg_var *arg, lv_op_t op)
{
    char            *s;
    char            *candidate;
    char            *running;
    dbspec_key      *spec;
    clicon_dbvars_t *dbv = NULL;
    int	             retval = -1;
    char            *str = NULL;

    if (arg != NULL) 
	str = cv_string_get(arg);
    if ((candidate = clicon_candidate_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "candidate db not set");
	goto quit;
    }
    if ((running = clicon_running_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "running db not set");
	goto quit;
    }
    spec = clicon_dbspec_key(h);
    
    if ((s = clicon_sock(h)) == NULL)
	return -1;

    if ((dbv = cli_set_parse(h, spec, candidate, vars, str?str:"")) == NULL)
	return -1;

    if (cli_usedaemon(h)) {
	if (cli_proto_change_cvec(h, candidate, op, dbv->dbv_key, dbv->dbv_vec) < 0)
	    goto quit;
    } else {
	if (db_lv_op_exec(spec, candidate, dbv->dbv_key, op, dbv->dbv_vec) < 0)
	    goto quit;
    }

    if (cli_usedaemon(h) && clicon_autocommit(h)) {
        if (cli_proto_commit(s, running, candidate, 0, 0) < 0) {
	    if (cli_proto_copy(s, running, candidate) < 0)
	        fprintf(stderr, "Failed to restore candidate: %s\n", 
			strerror(errno));
	    goto quit;
	}
    }

    retval = 0;
quit:
    if (dbv)
	clicon_dbvars_free(dbv);

    return retval;}


int 
cli_set(clicon_handle h, cvec *vars, cg_var *arg)
{
    return cli_dbop(h, vars, arg, LV_SET);
}

int 
cli_merge(clicon_handle h, cvec *vars, cg_var *arg)
{
    return cli_dbop(h, vars, arg, LV_MERGE);
}

int 
cli_del(clicon_handle h, cvec *vars, cg_var *arg)
{
    return cli_dbop(h, vars, arg, LV_DELETE);
}


/*! Load a configuration file to candidate database
 * @param[in] h     CLICON handle
 * @param[in] vars  Vector of variables (not needed) 
 * @param[in] arg   A string: "<varname> <op>" 
 *   <varname> is name of a variable occuring in the cligen command string.
 *   <op> is either "merge" or "replace"
 * @code
 *   # cligen spec
 *   load file <name2:string>, load_config_file("name2 merge");
 * @endcode
 */
int 
load_config_file(clicon_handle h, cvec *vars, cg_var *arg)
{
    int         ret = -1;
    struct stat st;
    char      **vec;
    char      **vecp;
    char       *filename;
    int         replace;
    char       *s;
    char       *dbname;
    char       *str;
    cg_var     *cv;
    int         nvec;
    char       *opstr;
    char       *varstr;

    if (arg == NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    if ((vec = clicon_strsplit(str, " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto done;
    }
    if (nvec != 2){
	clicon_err(OE_PLUGIN, 0, "Arg syntax is <varname> <replace|merge>");	
	goto done;
    }
    varstr = vec[0];
    opstr  = vec[1];
    if (strcmp(opstr, "merge") == 0) 
	replace = 0;
    else
    if (strcmp(opstr, "replace") == 0) 
	replace = 1;
    else{
	clicon_err(OE_PLUGIN, 0, "No such op: %s, expected merge or replace", opstr);	
	goto done;
    }
    if ((cv = cvec_find_var(vars, varstr)) == NULL){
	clicon_err(OE_PLUGIN, 0, "No such var name: %s", varstr);	
	goto done;
    }
    if ((vecp = clicon_realpath(NULL, cv_string_get(cv), __FUNCTION__)) == NULL){
	cli_output(stderr, "Failed to resolve filename\n");
	goto done;
    }
    filename = vecp[0];
    if ((dbname = clicon_candidate_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "candidate db not set");
	goto done;
    }
    if (stat(filename, &st) < 0){
 	clicon_err(OE_UNIX, 0, "load_config: stat(%s): %s\n", 
 		filename, strerror(errno));
	goto done;
    }
    if ((s = clicon_sock(h)) == NULL)
	return -1;
    if (cli_proto_load(s, replace, dbname, filename) < 0)
	goto done;

    ret = 0;
  done:
    return ret;
}

/*
 * save_config_file
 * Copy db to file Argument is database
 * arg is a string: "<dbname> <varname>" 
 *   <dbname>  is running or candidate
 *   <varname> is name of cligen variable in the cligen string.
 * Example (cligen spec): 
 *   save file <name:string>, save_config_file("running name");
 */
int
save_config_file(clicon_handle h, cvec *vars, cg_var *arg)
{
    int        retval = -1;
    char      *s;
    char     **vec;
    char     **vecp;
    char      *filename;
    char      *dbname;
    cg_var    *cv;
    int        nvec;
    char      *str;
    char      *dbstr;
    char      *varstr;

    if (arg == NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    if ((vec = clicon_strsplit(str, " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto done;
    }
    if (nvec != 2){
	clicon_err(OE_PLUGIN, 0, "Arg syntax is <dbname> <varname>");	
	goto done;
    }
    dbstr  = vec[0];
    varstr = vec[1];
    if (strcmp(dbstr, "running") == 0) 
	dbname = clicon_running_db(h);
    else
    if (strcmp(dbstr, "candidate") == 0) 
	dbname = clicon_candidate_db(h);
    else{
	clicon_err(OE_PLUGIN, 0, "No such db name: %s", dbstr);	
	goto done;
    }
    if (dbname == NULL){
	clicon_err(OE_FATAL, 0, "dbname not set");
	goto done;
    }

    if ((cv = cvec_find_var(vars, varstr)) == NULL){
	clicon_err(OE_PLUGIN, 0, "No such var name: %s", varstr);	
	goto done;
    }
    if ((vecp = clicon_realpath(NULL, cv_string_get(cv), __FUNCTION__)) == NULL){
	cli_output(stderr, "Failed to resolve filename\n");
	goto done;
    }
    filename = vecp[0];

    if ((s = clicon_sock(h)) == NULL)
	return -1;
  
    if (cli_proto_save(s, dbname, 0, filename) < 0) /*  */
	goto done;
    retval = 0;
    /* Fall through */
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}

int
delete_all(clicon_handle h, cvec *vars, cg_var *arg)
{
    char            *s;
    char            *dbname;
    char            *dbstr;
    int              retval = -1;

    if (arg == NULL || (dbstr = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    if (strcmp(dbstr, "running") == 0) 
	dbname = clicon_running_db(h);
    else
    if (strcmp(dbstr, "candidate") == 0) 
	dbname = clicon_candidate_db(h);
    else{
	clicon_err(OE_PLUGIN, 0, "No such db name: %s", dbstr);	
	goto done;
    }
    if (dbname == NULL){
	clicon_err(OE_FATAL, 0, "dbname not set");
	goto done;
    }
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    cli_proto_rm(s, dbname);
    cli_proto_initdb(s, dbname);
    retval = 0;
  done:
    return retval;
}

int
discard_changes(clicon_handle h, cvec *vars, cg_var *arg)
{
    char *s;
    char *running_db;
    char *candidate_db;
    int   retval = -1;

    s = clicon_sock(h);
    if ((candidate_db = clicon_candidate_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "candidate db not set");
	goto done;
    }
    if ((running_db = clicon_running_db(h)) == NULL){
	clicon_err(OE_FATAL, 0, "running db not set");
	goto done;
    }
    cli_proto_copy(s, running_db, candidate_db);
    retval = 0;
  done:
    return retval;
}


/*! Generic function for showing configurations.
 * the callback differs.
 * @param[in] h     CLICON handle
 * @param[in] vars  Vector of variables (not needed) 
 * @param[in] arg   A string: <dbname> <key> [<variable> <varname>]. 
 *   <dbname> is either running or candidate
 *   <key> is a database key or ~.*$ for all
 *   <variable> if given, then a match is made with a cv called <varname>
 * @param fn
 * @param fnarg
 * @code
 *    # cligen spec
 *   show config id <n:string>, show_conf_as("running ^MPoint.*$ Name n");
 * @endcode
 */
static int
show_conf_as(clicon_handle h, cvec *vars, cg_var *arg, 
	     dbmatch_fn_t fn, void *fnarg)
{
    cxobj *x0 = NULL; /* top xml */
    char            *regex;
    int              retval = -1;
    cg_var          *cv;
    char            *dbname;
    char            *attr = NULL;
    char            *val = NULL;
    char            *valname;
    char           **vec = NULL;
    int              nvec;
    char            *str;
    int              len;
    int              i;
    char           **keyv;
    cvec           **cvecv;

    if (arg == NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    if ((vec = clicon_strsplit(str, " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto done;
    }
    if (nvec != 2 && nvec != 4){
	clicon_err(OE_PLUGIN, 0, "format error \"%s\" - expected <dbname> <key> [<name> <variable>]", str);	
	goto done;
    }
    if (nvec > 2){
	attr = vec[2];
	valname = vec[3];
	cv = cvec_find_var(vars, valname);
	if (cv && (val = cv2str_dup(cv)) == NULL)
	    goto done;
    }
    /* Dont get attr here, take it from arg instead */
    if (strcmp(vec[0], "running") == 0) /* XXX: hardcoded */
	dbname = clicon_running_db(h);
    else
    if (strcmp(vec[0], "candidate") == 0) /* XXX: hardcoded */
	dbname = clicon_candidate_db(h);
    else{
	clicon_err(OE_PLUGIN, 0, "No such db name: %s", vec[0]);	
	goto done;
    }
    if (dbname == NULL){
	clicon_err(OE_FATAL, 0, "dbname not set");
	goto done;
    }
    regex = vec[1];
    if (dbmatch_vec(h, dbname, regex, attr, val, &keyv, &cvecv, &len) < 0)
	goto done;
    for (i=0; i<len; i++)
	if ((*fn)(h, dbname, keyv[i], cvecv[i], fnarg) < 0)
	    goto done;
    dbmatch_vec_free(keyv, cvecv, len);
    retval = 0;
done:
    unchunk_group(__FUNCTION__);
    if (x0)
	xml_free(x0);
    if (val)
	free(val);
    return retval;

}

/* callback used by show_conf_* just to merge xml */
static int
add2xml_cb(void *handle, char *dbname, char *key, cvec *vr, void *arg)
{
    cxobj *xt;

    xt = (cxobj*)arg;
    return key2xml(key, dbname, clicon_dbspec_key(handle), xt);
}

/*
 * Show a configuration database on stdout using XML format
 */
static int
show_conf_as_xml1(clicon_handle h, cvec *vars, cg_var *arg, int netconf)
{
    cxobj *xt = NULL;
    cxobj *xc;
    int              retval = -1;

    if ((xt = xml_new("tmp", NULL)) == NULL)
	goto done;
    if (show_conf_as(h, vars, arg, add2xml_cb, xt) < 0)
	goto done;
    if (netconf) /* netconf prefix */
	fprintf(stdout, "<rpc><edit-config><target><candidate/></target><config>\n");
    xc = NULL; /* Dont print xt itself */
    while ((xc = xml_child_each(xt, xc, -1)) != NULL)
	clicon_xml2file(stdout, xc, netconf?2:0, 1);
    if (netconf) /* netconf postfix */
	fprintf(stdout, "</config></edit-config></rpc>]]>]]>\n");
    retval = 0;
  done:
    if (xt)
	xml_free(xt);
    return retval;

}

int
show_conf_as_xml(clicon_handle h, cvec *vars, cg_var *arg)
{
    return show_conf_as_xml1(h, vars, arg, 0);
}

int
show_conf_as_netconf(clicon_handle h, cvec *vars, cg_var *arg)
{
    return show_conf_as_xml1(h, vars, arg, 1);
}

/*
 * @param as_cmd  Show as command, ie not tree format but as one-line commands
 */
static int
show_conf_as_text1(clicon_handle h, cvec *vars, cg_var *arg)
{
    cxobj       *xt = NULL;
    cxobj       *xc;
    int          retval = -1;

    if ((xt = xml_new("tmp", NULL)) == NULL)
	goto done;
    if (show_conf_as(h, vars, arg, add2xml_cb, xt) < 0)
	goto done;
    xc = NULL; /* Dont print xt itself */
    while ((xc = xml_child_each(xt, xc, -1)) != NULL)
	xml2txt(stdout, xc, 0); /* tree-formed text */
    retval = 0;
  done:
    if (xt)
	xml_free(xt);
    unchunk_group(__FUNCTION__);
    return retval;
}


/* Show configuration as commands, ie not tree format but as one-line commands
 */
static int
show_conf_as_command(clicon_handle h, cvec *vars, cg_var *arg, char *prepend)
{
    cxobj             *xt = NULL;
    cxobj             *xc;
    enum genmodel_type gt;
    int                retval = -1;

    if ((xt = xml_new("tmp", NULL)) == NULL)
	goto done;
    if (show_conf_as(h, vars, arg, add2xml_cb, xt) < 0)
	goto done;
    xc = NULL; /* Dont print xt itself */
    while ((xc = xml_child_each(xt, xc, -1)) != NULL){
	if ((gt = clicon_cli_genmodel_type(h)) == GT_ERR)
	    goto done;
	xml2cli(stdout, xc, prepend, gt, __FUNCTION__); /* cli syntax */
    }
    retval = 0;
  done:
    if (xt)
	xml_free(xt);
    unchunk_group(__FUNCTION__);
    return retval;
}

int
show_conf_as_text(clicon_handle h, cvec *vars, cg_var *arg)
{
    return show_conf_as_text1(h, vars, arg);
}

int
show_conf_as_cli(clicon_handle h, cvec *vars, cg_var *arg)
{
    return show_conf_as_command(h, vars, arg, NULL); /* XXX: how to set prepend? */
}

static int
cli_notification_cb(int s, void *arg)
{
    struct clicon_msg *reply;
    int                eof;
    int                retval = -1;
    char              *event = NULL;
    int                level;

    /* get msg (this is the reason this function is called) */
    if (clicon_msg_rcv(s, &reply, &eof, __FUNCTION__) < 0)
	goto done;
    if (eof){
	clicon_err(OE_PROTO, ESHUTDOWN, "%s: Socket unexpected close", __FUNCTION__);
	close(s);
	errno = ESHUTDOWN;
	event_unreg_fd(s, cli_notification_cb);
	goto done;
    }
    switch (reply->op_type){
    case CLICON_MSG_NOTIFY:
	if (clicon_msg_notify_decode(reply, &level, &event, __FUNCTION__) < 0) 
	    goto done;
	fprintf(stderr, "%s\n", event);
	break;
    default:
	clicon_err(OE_PROTO, 0, "%s: unexpected reply: %d", 
		__FUNCTION__, reply->op_type);
	goto done;
	break;
    }
    retval = 0;
  done:
    unchunk_group(__FUNCTION__); /* event allocated by chunk */
    return retval;

}

/*! Send a notify subscription to backend and un/register callback for return messages.
 * 
 * @param[in] h      Clicon handle
 * @param[in] vars   Not used
 * @param[in] arg    A string with log stream name and stream status
 * @code
 * cmd("comment"), cli_setlog("mystream 0"); # turn off logging of mystream
 * @endcode
 */
int
cli_setlog(clicon_handle h, cvec *vars, cg_var *arg)
{
    char            *sockpath;
    int              s;
    char            *stream = NULL;
    int              retval = -1;
    char           **vec = NULL;
    int              nvec;
    char            *str;
    int              status;
    clicon_hash_t   *cdat = clicon_data(h);
    void            *p;
    int              s_exist = -1;
    size_t           len;
    char            *logname;


    if (arg==NULL || (str = cv_string_get(arg)) == NULL){
	clicon_err(OE_PLUGIN, 0, "%s: requires string argument", __FUNCTION__);
	goto done;
    }
    if ((vec = clicon_strsplit(str, " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto done;
    }
    if (nvec != 2){
	clicon_err(OE_PLUGIN, 0, "format error \"%s\" - expected <stream> <status>", str);	
	goto done;
    }
    stream = vec[0];
    status = atoi(vec[1]);
    sockpath = clicon_sock(h);
    if ((logname = chunk_sprintf(__FUNCTION__, "log_socket_%s", stream)) == NULL){
	clicon_err(OE_PLUGIN, errno, "%s: chunk_sprintf", __FUNCTION__);
	goto done;
    }
    if ((p = hash_value(cdat, cmd, &len)) != NULL)
	s_exist = *(int*)p;

    if (status){
	if (s_exist!=-1){
	    clicon_err(OE_PLUGIN, 0, "%s: result log socket already exists", __FUNCTION__);
	    goto done;
	}
	if (cli_proto_subscription(sockpath, status, stream, &s) < 0)
	    goto done;
	if (cligen_regfd(s, cli_notification_cb, NULL) < 0)
	    goto done;
	fprintf(stderr, "%s: reg %d\n", __FUNCTION__, s);
	if (hash_add(cdat, logname, &s, sizeof(s)) == NULL)
	    goto done;
    }
    else{
	if (s_exist != -1){
	    cligen_unregfd(s_exist);
	}
	hash_del(cdat, logname);
	if (cli_proto_subscription(sockpath, status, stream, NULL) < 0)
	    goto done;

    }

    retval = 0;
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}

/* XXX backward comnpatible */
int 
cli_getlog(clicon_handle h, cvec *vars, cg_var *arg)
{
    return cli_setlog(h, vars, arg);
}

/* Translate XML -> CSV commands
 * Can only be made in a 'flat tree', ie on the form:
 * <X><A>B</A></X> --> 
 * Type, A
 * X,  B
 */
int 
xml2csv(FILE *f, cxobj *x, cvec *vh)
{
    cxobj *xe, *xb;
    int              retval = -1;
    cg_var          *vs;

    fprintf(f, "%s", xml_name(x));
    xe = NULL;

    vs = NULL;
    while ((vs = cvec_each(vh, vs))) {
	if ((xe = xml_find(x, cv_name_get(vs))) == NULL){
	    fprintf(f, ";");
	    continue;
	}
	if (xml_child_nr(xe)){
	    xb = xml_child_i(xe, 0);
	    fprintf(f, ";%s", xml_value(xb));
	}
    }
    fprintf(f, "\n");
    retval = 0;
    return retval;

}


static int
show_conf_as_csv1(clicon_handle h, cvec *vars, cg_var *arg)
{
    cxobj *xt = NULL;
    cxobj *xc;
    int              retval = -1;
    dbspec_key  *dbspec, *ds=NULL; 
    cg_var          *vs;
    cvec            *vh=NULL;
    char            *str;

    dbspec = clicon_dbspec_key(h);
    if ((xt = xml_new("metrio", NULL)) == NULL)
	goto done;
    if (show_conf_as(h, vars, arg, add2xml_cb, xt) < 0)
	goto done;

    xc = NULL; /* Dont print xt itself */
    while ((xc = xml_child_each(xt, xc, -1)) != NULL){
	if ((str = chunk_sprintf(__FUNCTION__, "%s[]", xml_name(xc))) == NULL)
	    goto done;
	if (ds==NULL && (ds = key2spec_key(dbspec, str)) != NULL){
	    fprintf(stdout, "Type");
	    vh = db_spec2cvec(ds);
	    vs = NULL;
	    while ((vs = cvec_each(vh, vs))) 
		fprintf(stdout, ";%s",	cv_name_get(vs));
	    fprintf(stdout, "\n");
	} /* Now values just need to follow,... */
	if (vh== NULL)
	    goto done;
	xml2csv(stdout, xc, vh); /* cli syntax */
    }

    retval = 0;
  done:
    if (xt)
	xml_free(xt);
    unchunk_group(__FUNCTION__);
    return retval;
}

int
show_conf_as_csv(clicon_handle h, cvec *vars, cg_var *arg)
{
    return show_conf_as_csv1(h, vars, arg);
}
