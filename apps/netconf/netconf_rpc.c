/*
 *  CVS Version: $Id: netconf_rpc.c,v 1.38 2013/08/15 11:52:08 olof Exp $
 *
  Copyright (C) 2009-2013 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 *  Code for handling netconf rpc messages
 *****************************************************************************/
#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/param.h>
#include <assert.h>
#include <grp.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

#include "clicon_netconf.h"
#include "netconf_lib.h"
#include "netconf_filter.h"
#include "netconf_plugin.h"
#include "netconf_rpc.h"

/*
 * <rpc [attributes]> 
    <!- - tag elements in a request from a client application - -> 
    </rpc> 
 */

/*
 * See get-config
 * xfilter is a filter expression starting with <filter>

 */
static int
netconf_filter(struct db_spec *dbspec, struct xml_node *xfilter, 
	       xf_t *xf, xf_t *xf_err, 
	       struct xml_node *xt, char *target)
{
    struct xml_node *xdb = NULL; 
    struct xml_node *xc; 
    struct xml_node *xfilterconf = NULL; 
    char *type;
    char *ftype;
    int retval = -1;

    if ((xdb = db2xml(target, dbspec, "clicon")) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "operation-failed", 
				 "application", 
				 "error", 
				 NULL,
				 "read-registry");
	goto done;
    }
    /* 
     * Note, there is a difference in the rfc between no filter and empty filter.
     * If no filter, return the whole configuration. If empty filter, then
     * return nothing.
     */
    if (xfilter){
	if ((ftype = xml_get(xfilter, "type")) != NULL){
	    if (strcmp(ftype, "xpath")==0){
		retval = netconf_xpath(dbspec, xdb, xfilter, xf, xf_err, xt, target);
		goto done;
	    }
	    else{
		netconf_create_rpc_error(xf_err, xt, 
				 "operation-failed", 
				 "application", 
				 "error", 
				 NULL,
				 "type");
		goto done;
	    }
	}


	xfilterconf = xml_xpath(xfilter, "//configuration");
	if (xfilterconf == NULL){ 
	    retval = 0;
	    goto done;
	}
    }

    /* Add <configuration> under <top> */
    if ((xc = xml_insert(xdb, "configuration")) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "operation-failed", 
				 "application", 
				 "error", 
				 NULL,
				 "filtering");
	goto done;
    }
    if (xfilterconf != NULL){
	if ((type = xml_get(xfilterconf, "type")) != NULL && strcmp(type, "subtree")){
	    netconf_create_rpc_error(xf_err, xt, 
				     "bad-attribute", 
				     "protocol", 
				     "error", 
				     NULL,
				     "<bad-attribute>type</bad-attribute>");
	    goto done;
	}
	if (xml_filter(xfilterconf, xc) < 0){
	    netconf_create_rpc_error(xf_err, xt, 
				     "operation-failed", 
				     "application", 
				     "error", 
				     NULL,
				     "filtering");
	    goto done;
	}

    }
    if (xc->xn_nrchildren){
	if (debug)
	    xml_to_file(stderr, xc, 0, 1);
	print_xml_xf_node(xf, xc, 0, 1);
    }
    retval = 0;
  done:
    if (xdb)
	xml_free(xdb);
    return retval; 
}


/*
    <get-config> 
        <source> 
            <( candidate | running )/> 
        </source> 
    </get-config> 
    
    <get-config> 
        <source> 
            <( candidate | running )/> 
        </source> 
        <filter type="subtree"> 
            <configuration> 
                <!- - tag elements for each configuration element to return - -> 
            </configuration> 
        </filter> 
    </get-config> 
 */
int
netconf_get_config(clicon_handle h, struct db_spec *dbspec,
		   struct xml_node *xn, 
		   xf_t *xf, xf_t *xf_err, 
		   struct xml_node *xt)
{
    struct xml_node *xfilter; /* filter */
    int retval = -1;
    char *target;

    if ((target = get_target(h, xn, "/source")) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "missing-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>source</bad-element>");
	goto done;
    }
    xfilter = xml_xpath(xn, "//filter");
    if (netconf_filter(dbspec, xfilter, xf, xf_err, xt, target) < 0)
	goto done;
    retval = 0;
  done:
    return retval;
}



/*
 * get_edit_opts
 * Get opts from: 
 *  <edit-config>
 *     <config>XXX</config>
 *     <default-operation>(merge | none | replace)</default-operation> 
 *     <error-option>(stop-on-error | continue-on-error )</error-option> 
 *     <test-option>(set | test-then-set | test-only)</test-option> 
 *  </edit-config>
 * 
 *
 */
static int
get_edit_opts(struct xml_node *xn,
		 enum operation_type *op, 
		 enum test_option *testopt,
		 enum error_option *erropt,
		 xf_t *xf_err, 
		 struct xml_node *xt) 
{
    struct xml_node *x;
    char *optstr;
    int retval = -1;

    if ((x = xml_xpath(xn, "/default-operation")) != NULL){
	if ((optstr = xml_get_body(x)) != NULL){
	    if (strcmp(optstr, "replace") == 0)
		*op = OP_REPLACE;
	    else
		if (strcmp(optstr, "merge") == 0)
		    *op = OP_MERGE;
		else
		    if (strcmp(optstr, "none") == 0)
			*op = OP_NONE;
		    else{
			netconf_create_rpc_error(xf_err, xt, 
						 "invalid-value", 
						 "protocol", 
						 "error", 
						 NULL,
						 NULL);
			goto done;
		    }
	}
    }
    if ((x = xml_xpath(xn, "/test-option")) != NULL){
	if ((optstr = xml_get_body(x)) != NULL){
	    if (strcmp(optstr, "test-then-set") == 0)
		*testopt = TEST_THEN_SET;
	    else
	    if (strcmp(optstr, "set") == 0)
		*testopt = SET;
	    else
	    if (strcmp(optstr, "test-only") == 0)
		*testopt = TEST_ONLY;
	    else{
		netconf_create_rpc_error(xf_err, xt, 
					 "invalid-value", 
					 "protocol", 
					 "error", 
					 NULL,
					 NULL);
		goto done;
	    }
	}
    }
    if ((x = xml_xpath(xn, "/error-option")) != NULL){
	if ((optstr = xml_get_body(x)) != NULL){
	    if (strcmp(optstr, "stop-on-error") == 0)
		*erropt = STOP_ON_ERROR;
	    else
	    if (strcmp(optstr, "continue-on-error") == 0)
		*erropt = CONTINUE_ON_ERROR;
	    else{
		netconf_create_rpc_error(xf_err, xt, 
					 "invalid-value", 
					 "protocol", 
					 "error", 
					 NULL,
					 NULL);
		goto done;
	    }
	}
    }
    retval = 0;
  done:
   return retval;
}

/*
    <edit-config> 
        <target> 
            <candidate/> 
        </target> 
    
    <!- - EITHER - -> 

        <config> 
            <configuration> 
                <!- - tag elements representing the data to incorporate - -> 
            </configuration> 
        </config> 

    <!- - OR - -> 
    
        <config-text> 
            <configuration-text> 
                <!- - tag elements inline configuration data in text format - -> 
            </configuration-text> 
        </config-text> 

    <!- - OR - -> 

        <url> 
            <!- - location specifier for file containing data - -> 
        </url> 
    
        <default-operation>(merge | none | replace)</default-operation> 
        <error-option>(stop-on-error | continue-on-error )</error-option> 
        <test-option>(set | test-then-set | test-only)</test-option> 
    <edit-config> 
 *
 * only 'config' supported
 * error-option: only stop-on-error supported
 * test-option:  not supported
 *
 *
 */
int
netconf_edit_config(clicon_handle h,
		    struct db_spec *dbspec,
		    struct xml_node *xn, 
		    xf_t *xf, 
		    xf_t *xf_err, 
		    struct xml_node *xt)
{
    int                 retval = -1;
    enum operation_type operation = OP_MERGE;
    enum test_option    testopt = TEST_THEN_SET;
    enum error_option   erropt = STOP_ON_ERROR;
    struct xml_node    *xc;      /* config */
    char               *target;  /* db */
    char               *s;       /* config socket */
    struct clicon_msg  *msg;     
    char               *tmpfile;
    FILE               *f;
    char              *config_group;
    gid_t              gid;

    /* must have target, and it should be candidate */
    if ((target = get_target(h, xn, "/target")) == NULL ||
	strcmp(target, clicon_candidate_db(h))){
	netconf_create_rpc_error(xf_err, xt, 
				 "missing-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>target</bad-element>");
	goto done;
    }
    if (get_edit_opts(xn, &operation, &testopt, &erropt, xf_err, xt) < 0)
	goto done;
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    switch(operation){
    case OP_REPLACE: /* replace or create config-data */
    case OP_MERGE: /* merge config-data */
	if ((xc  = xml_xpath(xn, "//config")) != NULL){
	    if ((tmpfile = clicon_tmpfile(__FUNCTION__)) == NULL)
		goto done;

	    if ((f = fopen(tmpfile, "w")) == NULL){
		clicon_err(OE_UNIX, errno, "fopen");
		unlink(tmpfile);
		goto done;
	    }
	    /* also read by group */
	    if ((config_group = clicon_sock_group(h)) == NULL)
		return -1;
	    if (group_name2gid(config_group, &gid) < 0)
		return -1;

	    if (lchown(tmpfile, -1, gid) < 0){
		clicon_err(OE_UNIX, errno, "%s: lchown()", __FUNCTION__); 
		goto done;
	    }
	    if (chmod(tmpfile, S_IRUSR|S_IWUSR|S_IRGRP) < 0){
		clicon_err(OE_UNIX, errno, "%s: chmod()", __FUNCTION__); 
		goto done;
	    }

	    snprintf(xc->xn_name, strlen(xn->xn_name)+1, "clicon"); /* NOTE: same length as "config" */
	    if (xml_to_file(f, xc, 0, 1) < 0){
		fclose(f);
		unlink(tmpfile);
		goto done;
	    }
	    fclose(f);
	    if ((msg=clicon_msg_load_encode(operation==OP_REPLACE, 
					    target, 
					    tmpfile,
					    __FUNCTION__)) == NULL){
		unlink(tmpfile);
		goto done;
	    }
	    if (clicon_rpc_connect(msg, s, NULL, 0, __FUNCTION__) < 0){
		netconf_create_rpc_error(xf_err, xt, 
					 "access-denied", 
					 "protocol", 
					 "error", 
					 NULL,
					 "edit_config");
		unlink(tmpfile);
		goto done;

	    }
	    unlink(tmpfile);
	}
	break;
    case OP_NONE: /* combine with operations attribute */
    default:
	break;
    }
    netconf_ok_set(1);
    retval = 0;
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}

/*
    <copy-config> 
        <target> 
            <candidate/> 
        </target> 
        <source> 
            <url> 
                <!- - location specifier for file containing the new configuration - -> 
            </url> 
        </source> 
    <copy-config> 
 */
int
netconf_copy_config(clicon_handle h,
		    struct xml_node *xn, 
		    xf_t *xf, xf_t *xf_err, 
		    struct xml_node *xt)
{
    char              *source, *target; /* filenames */
    struct clicon_msg *msg;     /* inline from cli_proto_copy */
    int                retval = -1;
    char              *s;

    if ((source = get_target(h, xn, "/source")) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "missing-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>source</bad-element>");
	goto done;
    }
    if ((target = get_target(h, xn, "/target")) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "missing-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>source</bad-element>");
	goto done;
    }

#ifdef notyet
    /* If target is locked and not by this client, then return an error */
    if (target_locked(&client) > 0 && client != ce_nr){
	netconf_create_rpc_error(xf_err, xt, 
				 "access-denied", 
				 "protocol", 
				 "error", 
				 NULL,
				 "lock");
	goto done;
    }
#endif
    /* inline from cli_proto_copy */
    if ((msg=clicon_msg_copy_encode(source, target,
				   __FUNCTION__)) == NULL)
	goto done;

    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (clicon_rpc_connect(msg, s, NULL, 0, __FUNCTION__) < 0)
	goto done;
    netconf_ok_set(1);
    retval = 0;
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}

/*
  <delete-config> 
        <target> 
            <candidate/> 
        </target> 
    </delete-config> 
    Delete a configuration datastore.  The <running>
    configuration datastore cannot be deleted.
 */
int
netconf_delete_config(clicon_handle h,
		      struct xml_node *xn, 
		      xf_t *xf, xf_t *xf_err, 
		      struct xml_node *xt)
{
    char              *target; /* filenames */
    struct clicon_msg *msg;     /* inline from cli_proto_copy */
    int                retval = -1;
    char              *s;

    if ((target = get_target(h, xn, "/target")) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "missing-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>target</bad-element>");
	goto done;
    }
    if (strcmp(target, clicon_candidate_db(h))){
	netconf_create_rpc_error(xf_err, xt, 
				 "bad-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>target</bad-element>");
	goto done;
    }
    if ((msg=clicon_msg_rm_encode(target, __FUNCTION__)) == NULL)
	goto done;
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (clicon_rpc_connect(msg, s, NULL, 0, __FUNCTION__) < 0){
	netconf_create_rpc_error(xf_err, xt, 
				 "access-denied", 
				 "protocol", 
				 "error", 
				 NULL,
				 "remove target");
	goto done;
    }
    if ((msg=clicon_msg_initdb_encode(target, __FUNCTION__)) == NULL)
	goto done;
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (clicon_rpc_connect(msg, s, NULL, 0, __FUNCTION__) < 0){
	netconf_create_rpc_error(xf_err, xt, 
				 "access-denied", 
				 "protocol", 
				 "error", 
				 NULL,
				 "remove target");
	goto done;
    }

    netconf_ok_set(1);
    retval = 0;
  done:
    return retval;
}

/*
    <close-session/> 
*/
int
netconf_close_session(struct xml_node *xn, xf_t *xf, xf_t *xf_err, struct xml_node *xt)
{
    cc_closed++;
    netconf_ok_set(1);
    return 0;
}

/*
    <lock> 
        <target> 
            <candidate/> 
        </target> 
    </lock> 
 */
int
netconf_lock(clicon_handle h,
	     struct xml_node *xn, 
	     xf_t *xf, xf_t *xf_err, 
	     struct xml_node *xt)
{
    char *target;
    int retval = -1;

    if ((target = get_target(h, xn, "/target")) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "missing-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>source</bad-element>");
	goto done;
    }
#ifdef notyet
    if (target_locked(&client) > 0){
	snprintf(info, 64, "<session-id>%d</session-id>", client);
	netconf_create_rpc_error(xf_err, xt, 
				 "lock-denied", 
				 "protocol", 
				 "error", 
				 "Lock failed, lock is already held",
				 info);
	return -1;
    }

    if (lock_target(target) < 0){
	netconf_create_rpc_error(xf_err, xt, 
				 "lock-denied", 
				 "protocol", 
				 "error", 
				 "Lock failed, lock is already held",
				 NULL);
	return -1;
    }
#endif
    netconf_ok_set(1);
    retval = 0;
  done:
    return retval;
}

/*
   <unlock> 
        <target> 
            <candidate/> 
        </target> 
    </unlock> 
 */
int
netconf_unlock(clicon_handle h, 
	       struct xml_node *xn, 
	       xf_t *xf, xf_t *xf_err, 
	       struct xml_node *xt)
{
    char *target;
    int retval = -1;

    if ((target = get_target(h, xn, "/target")) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "missing-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>target</bad-element>");
	goto done;
    }
#ifdef notyet
    if (target_locked(&client) == 0){
	netconf_create_rpc_error(xf_err, xt, 
				 "lock-denied", 
				 "protocol", 
				 "error", 
				 "Unlock failed, lock is not held",
				 NULL);
	return -1;
    }

    if (client != ce_nr){
	snprintf(info, 64, "<session-id>%d</session-id>", client);
	netconf_create_rpc_error(xf_err, xt, 
				 "lock-denied", 
				 "protocol", 
				 "error", 
				 "Unlock failed, lock is held by other entity",
				 info);
	return -1;
    }
    if (unlock_target(target) < 0){
	netconf_create_rpc_error(xf_err, xt, 
				 "lock-denied", 
				 "protocol", 
				 "error", 
				 "Unlock failed, unkown reason",
				 NULL);
	return -1;
    }
#endif /* notyet */
    netconf_ok_set(1);
    retval = 0;
  done:
    return retval;
}

/*
  <kill-session> 
        <session-id>PID</session-id> 
  </kill-session> 
 */
int
netconf_kill_session(struct xml_node *xn, xf_t *xf, xf_t *xf_err, struct xml_node *xt)
{
#ifdef notyet
    struct xml_node *xsessionid;
    int client;

    if ((xsessionid = xml_xpath(xn, "//session-id")) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "missing-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>session-id</bad-element>");
	return -1;
    }
    if (xml_get(xsessionid, "body") == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "missing-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>session-id</bad-element>");
	return -1;
    }
    client = xml_get_int(xsessionid, "body");
    if ((ce = find_ce_bynr(client)) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "operation-failed", 
				 "protocol", 
				 "error", 
				 NULL,
				 "No such client");
	return -1;
    }
//    ce_change_state(ce, CS_CLOSED, "Received close-session msg");
    netconf_ok_set(1);
#endif
    return 0;
}

/*
    <commit/> 
    :candidate
 */
int
netconf_commit(clicon_handle h,
	       struct xml_node *xn, 
	       xf_t *xf, xf_t *xf_err, 
	       struct xml_node *xt)
{
    struct clicon_msg *msg;     /* inline from cli_proto_commit */
    int                retval = -1;
    char              *s;

    if ((msg=clicon_msg_commit_encode(clicon_candidate_db(h),
				      clicon_running_db(h), 
				      1, 1, 
				     __FUNCTION__)) == NULL){
	   netconf_create_rpc_error(xf_err, xt, 
				    "operation-failed", 
				    "protocol", "error", 
				    NULL, "Internal error"); 
	goto done;
    }
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (clicon_rpc_connect(msg, s, NULL, 0, __FUNCTION__) < 0){
	   netconf_create_rpc_error(xf_err,               /* msg buffer */
				    xt,                   /* orig request */
				    "operation-failed",   /* tag */
				    "protocol",           /* type */
				    "error",              /* severity */
		      clicon_strerror(clicon_errno),      /* message */
    strlen(clicon_err_reason)?clicon_err_reason:"Internal error");/* info */
	goto done;
    }
    netconf_ok_set(1);
    retval = 0;
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}

/*
    <discard-changes/> 
    :candidate
 */
int
netconf_discard_changes(clicon_handle h,
			struct xml_node *xn, xf_t *xf, xf_t *xf_err, 
			struct xml_node *xt)
{
    struct clicon_msg *msg;     /* inline from cli_proto_copy */
    int                retval = -1;
    char              *s;

    if ((msg=clicon_msg_copy_encode(clicon_running_db(h),
				    clicon_candidate_db(h),
				   __FUNCTION__)) == NULL)
	goto done;
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (clicon_rpc_connect(msg, s, NULL, 0, __FUNCTION__) < 0){
	   netconf_create_rpc_error(xf_err, xt, 
				    "operation-failed", 
				    "protocol", "error", 
				    NULL, "Internal error"); 
	goto done;
    }
    netconf_ok_set(1);
    retval = 0;
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}

/*
    <validate/> 
    :validate
 */
int
netconf_validate(clicon_handle h, 
		 struct xml_node *xn, 
		 xf_t *xf, xf_t *xf_err, 
		 struct xml_node *xt)
{
    char *target;
    int retval = -1;

    if ((target = get_target(h, xn, "/source")) == NULL){
	netconf_create_rpc_error(xf_err, xt, 
				 "missing-element", 
				 "protocol", 
				 "error", 
				 NULL,
				 "<bad-element>target</bad-element>");
	goto done;
    }
    /* Do validation */
    netconf_ok_set(1);
    retval = 0;
  done:
    return retval;
}

/*
 * netconf_rpc_dispatch
 * Big rpc dispatcher. Look at first tag and dispach to sub-functions.
 * Call plugin handler if tag not found. If not handled by any handler, return
 * error.
 * Input:
 *  h       - clicon handle option
 *  dbspec  - database specification
 *  xorig   - Original request.
 *  xn      - Sub-tree (under xorig) at <rpc>...</rpc> level.
 *  xf      - Output xml stream. For reply
 *  xf_err  - Error xml stream. For error reply
 */
int
netconf_rpc_dispatch(clicon_handle h,
		     struct db_spec *dbspec,
		     struct xml_node *xorig, 
		     struct xml_node *xn, 
		     xf_t *xf, 
		     xf_t *xf_err)
{
    struct xml_node *xe;
    int ret = 0;
    
    xe = NULL;
   while ((xe = xml_child_each(xn, xe, XML_ELEMENT)) != NULL) {
       if (strcmp(xe->xn_name, "close-session") == 0)
	   return netconf_close_session(xe, xf, xf_err, xorig);
       else
       if (strcmp(xe->xn_name, "get-config") == 0)
	   return netconf_get_config(h, dbspec, xe, xf, xf_err, xorig);
       else
       if (strcmp(xe->xn_name, "get") == 0) /* TBD */
	   ;
       else
       if (strcmp(xe->xn_name, "edit-config") == 0) /* TBD */
	   return netconf_edit_config(h, dbspec, xe, xf, xf_err, xorig);
       else
       if (strcmp(xe->xn_name, "copy-config") == 0)
	   return netconf_copy_config(h, xe, xf, xf_err, xorig);
       else
       if (strcmp(xe->xn_name, "delete-config") == 0)
	   return netconf_delete_config(h, xe, xf, xf_err, xorig);
       else
       if (strcmp(xe->xn_name, "kill-session") == 0) /* TBD */
	   return netconf_kill_session(xe, xf, xf_err, xorig);
       else
       if (strcmp(xe->xn_name, "lock") == 0) /* TBD */
	   return netconf_lock(h, xe, xf, xf_err, xorig);
       else
       if (strcmp(xe->xn_name, "unlock") == 0) /* TBD */
	   return netconf_unlock(h, xe, xf, xf_err, xorig);
       else
       if (strcmp(xe->xn_name, "commit") == 0)
	   return netconf_commit(h, xe, xf, xf_err, xorig);
       else
       if (strcmp(xe->xn_name, "discard-changes") == 0)
	   return netconf_discard_changes(h, xe, xf, xf_err, xorig);
       else
       if (strcmp(xe->xn_name, "validate") == 0)
	   return netconf_validate(h, xe, xf, xf_err, xorig);
       else{
	   if ((ret = netconf_plugin_callbacks(h, xe, xf, xf_err, xorig)) < 0)
	       return -1;
	   if (ret == 0){ /* not handled by callback */
	       netconf_create_rpc_error(xf_err, xorig, 
					"operation-failed", 
					"rpc", "error", 
					xe->xn_name, "Not recognized"); 
	       ret = -1;
	   }
	   
       }
   }
    return ret;
}

/*
 * netconf_create_rpc_reply
 * Create an rpc reply msg in xf
 * Then send it using send_msg_to_client()
 */
int 
netconf_create_rpc_reply(xf_t *xf,            /* msg buffer */
			 struct xml_node *xr, /* orig request */
			 char *body,
			 int ok
    )
{
    struct xml_node *xn, *xa;
    int i;

    add_preamble(xf);
    xprintf(xf, "<rpc-reply"); /* attributes from rpc */
    if (xr && (xn=xml_xpath(xr, "//rpc")) != NULL){
	for (i=0; i<xn->xn_nrchildren; i++){
	    xa = xn->xn_children[i];
	    if (xa->xn_type != XML_ATTRIBUTE)
		continue;
	    xprintf(xf, " %s=\"%s\"", xa->xn_name, xa->xn_value);
	}
    }
    xprintf(xf, ">");
    if (ok) /* Just _maybe_ we should send data instead of ok if (if there is any)
	       even if ok is set? */
	xprintf(xf, "<ok/>");
    else{
	xprintf(xf, "<data>");
	xprintf(xf, "%s", body);
	xprintf(xf, "</data>");
    }
    xprintf(xf, "</rpc-reply>");
    add_postamble(xf);
    return 0;
}


/*
 * netconf_create_rpc_error
 * Create an rpc error msg in xf
 * (Then it should be sent at a later stage using send_msg_to_client() )
 * Arguments:
 *  xf   msg buffer to construct netconf message in
 *  xr   original request including an "rpc" tag
 *  ...  arguments to rpc-error reply message
 */
int 
netconf_create_rpc_error(xf_t *xf,            /* msg buffer */
			 struct xml_node *xr, /* orig request */
			 char *tag, 
			 char *type,
			 char *severity, 
			 char *message, 
			 char *info)
{
    add_error_preamble(xf, tag);
    xprintf(xf, "<rpc-reply>");
    xprintf(xf, "<rpc-error>");
    if (tag)
	xprintf(xf, "<error-tag>%s</error-tag>", tag);
    xprintf(xf, "<error-type>%s</error-type>", type);
    xprintf(xf, "<error-severity>%s</error-severity>", severity);
    if (message)
	xprintf(xf, "<error-message>%s</error-message>", message);
    if (info)
	xprintf(xf, "<error-info>%s</error-info>", info);
    xprintf(xf, "</rpc-error>");
    xprintf(xf, "</rpc-reply>");
    add_error_postamble(xf);
    return 0;
}

