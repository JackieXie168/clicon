/*
 *  CVS Version: $Id: config_dbdiff.c,v 1.20 2013/09/18 19:22:56 olof Exp $
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 * Code for comparing databases
 * XXX: needs clicon_err()
 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <regex.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

#include "config_dbdiff.h"


static int
dbdiff_add(char *basekey1, char *basekey2, 
	   enum dbdiff_op        dd_op, 
	   struct dbdiff        *df, 
	   const char *label)
{
    char *key1 = NULL;
    char *key2 = NULL;
    int retval = -1;
    struct dbdiff_ent *dfe, *newents;

    if (basekey1 && 
	(key1 = chunkdup(basekey1, strlen(basekey1)+1, label)) == NULL){
	clicon_err(OE_DB, errno, "%s: chunkdup", __FUNCTION__);
	goto quit;
    }
    if (basekey2 &&
	(key2 = chunkdup(basekey2, strlen(basekey2)+1, label)) == NULL){
	clicon_err(OE_DB, errno, "%s: chunkdup", __FUNCTION__);
	goto quit;
    }
    df->df_nr++;
    if ((newents = rechunk(df->df_ents, 
			  df->df_nr * sizeof(struct dbdiff_ent), 
			   label)) == NULL){
	clicon_err(OE_DB, errno, "%s: rechunk", __FUNCTION__);
	goto quit;
    }
    df->df_ents = newents;
    dfe = &df->df_ents[df->df_nr-1];
    memset(dfe, 0, sizeof(*dfe));
    dfe->dfe_key1 = key1;
    dfe->dfe_key2 = key2;
    dfe->dfe_op   = dd_op;
    retval = 0;
  quit:
    return retval;
}

/*!
 * \brief Check if regular key 'key' exists in first, second or both databases.
 * Args:
 *    db1    First database
 *    db2    Second database
 *    key    db key
 *    df     database diff result struct
 *    label  chunk label
 */
static int
dbdiff_single(char *db1, char *db2,
	      char *key,
	      struct dbdiff *df,
	      const char *label)
{
    char  *lvec1;
    size_t lvec1_len;
    char  *lvec2;
    size_t lvec2_len;
    int    eq;
    int    retval = -1;

    if (db_get_alloc(db1,  	/* Get value from database 1 */
		     key, 
		     (void*)&lvec1, 
		     &lvec1_len) < 0)
	return -1;
    if (db_get_alloc(db2, 	/* Get value from database 2 */
		     key, 
		     (void*)&lvec2, 
		     &lvec2_len) < 0){
	free(lvec1);
	goto done;
    }
    eq = 0;
    if (lvec1_len == lvec2_len){
	if (lvec1_len == 0){
	    /* difference between lvec=NULL (no-entry) and "" (empty) */
	    if (lvec1==NULL && lvec2==NULL)
		eq++;
	    else
		if (lvec1 && lvec2) /* "" */
		    eq++;
	}
	else{
	    if (memcmp(lvec1, lvec2, lvec1_len) == 0)
		eq++;
	    }
    }

    if (!eq){
	if (lvec1 != NULL && lvec2 != NULL){
	    if (dbdiff_add(key, key, DBDIFF_OP_BOTH, df, label) < 0)
		goto done;
	}
	else
	    if (lvec1 == NULL){
		if (dbdiff_add(NULL, key, DBDIFF_OP_SECOND, df,  label) < 0)
		    goto done;
	    }
	    else{
		if (dbdiff_add(key, NULL, DBDIFF_OP_FIRST, df, label) < 0)
		    goto done;
	    }
    }
    retval = 0;
  done:
    if (lvec1)
	free(lvec1);
    if (lvec2)
	free(lvec2);
    return retval;
}	    

/*
 * dbdiff_vector
 * XXX: optimize as follows: find the unique vars of the dbspec (pass it)
 * get their value of the first list in the outer loop using cv_name_get().
 * compare these with the inner loop (we should know the type) using cv_cmp.
 * That is, cache the unique variables per 
 * 
 */
static int
dbdiff_vector(char *db1, char *db2, 
	      char *key,
	      struct dbdiff *df,
	      const char *label)
{
    int                   i1;
    int                   i2;
    int                   npairs1 = 0;
    int                   npairs2 = 0;
    struct db_pair       *pairs1;
    struct db_pair       *pairs2;
    struct {cvec *vars;} *v1 = NULL; /* cache of cvecs */
    struct {cvec *vars;} *v2 = NULL; 
    int                   retval = -1;

    /* List all matches from both db's */
    if ((npairs1 = db_regexp(db1, key, __FUNCTION__, &pairs1, 0)) < 0)
	goto quit;
    if ((v1 = calloc(npairs1, sizeof(cvec *))) == NULL){
	clicon_err(OE_DB, errno, "%s: calloc", __FUNCTION__);
	goto quit;
    }
    if ((npairs2 = db_regexp(db2, key, __FUNCTION__, &pairs2, 0)) < 0)
	goto quit;
    if ((v2 = calloc(npairs2, sizeof(cvec *))) == NULL){
	clicon_err(OE_DB, errno, "%s: calloc", __FUNCTION__);
	goto quit;
    }
    for (i1 = 0; i1 < npairs1; i1++) 
	if ((v1[i1].vars = lvec2cvec (pairs1[i1].dp_val, pairs1[i1].dp_vlen)) == NULL)
	    goto quit;
    for (i2 = 0; i2 < npairs2; i2++) 
	if ((v2[i2].vars = lvec2cvec (pairs2[i2].dp_val, pairs2[i2].dp_vlen)) == NULL)
	    goto quit;
    /* Loop through db1 pairs and check with db2 for adds or modifications */
    for (i1 = 0; i1 < npairs1; i1++) {
	/* Create variable mapping */
	for (i2 = 0; i2 < npairs2; i2++) {
	    /* Create variable mapping */
	    if (lv_matchvar (v1[i1].vars, v2[i2].vars, 0)) {
		/* We have a match. Now compare all values */
		if (lv_matchvar (v1[i1].vars, v2[i2].vars, 1) == 0){
		    if (dbdiff_add(pairs1[i1].dp_key, pairs2[i2].dp_key, 
				   DBDIFF_OP_BOTH, df, label) < 0)
			goto quit;
		}
		break;		/* break the loop */
	    }
	}
    
	if (i2 >= npairs2){	/* No match means we have added something */
	    if (dbdiff_add(pairs1[i1].dp_key, NULL, 
			   DBDIFF_OP_FIRST, df, label) < 0)
		goto quit;
	}
    }
    /* Now loop through db2 pairs and check for deleted entries in db1 pairs */
    for (i2 = 0; i2 < npairs2; i2++) {
	/* Create variable mapping */
	for (i1 = 0; i1 < npairs1; i1++) {
	    /* Create variable mapping */
	    if (lv_matchvar(v2[i2].vars, v1[i1].vars, 0)) {
		/* We have a match. This entry exist. Break the loop */
		break;		/* break the loop */
	    }
	}
	if (i1 >= npairs1){	/* No match means we have deleted something */
	    if (dbdiff_add(NULL, pairs2[i2].dp_key, 
			   DBDIFF_OP_SECOND, df, label) < 0)
		goto quit;
	}
    }
    retval = 0;
  quit:
    if (v1){
	for (i1 = 0; i1 < npairs1; i1++) 
	    if (v1[i1].vars)
		free (v1[i1].vars);
	free(v1);
    }
    if (v2){
	for (i2 = 0; i2 < npairs2; i2++) 
	    if (v2[i2].vars)
		free (v2[i2].vars);
	free(v2);
    }
    unchunk_group(__FUNCTION__);
    return retval;
}	    




/* for caching variables and unique value */
struct _dbvars{
    cvec         *vars; 
    cg_var       *cv;
    char         *key;
}; 

static int
dbcmp(const void* arg1, const void* arg2)
{
    struct _dbvars *d1 = (struct _dbvars *)arg1;
    struct _dbvars *d2 = (struct _dbvars *)arg2;

    return cv_cmp(d1->cv, d2->cv);
}

/* 
 * dbdiff_vector_1
 * Optimized variant of dbdiff_vector() for keys with one unique variable
 * Optimized using two sorted string arrays with linear complexity.
 * We could generalize with more than one unique variable to get rid of 
 * dbdiff_vector() bit it is still needed as fallback for the general case.
 * Now, dbregexp is the one eating most cycles 
*/
static int
dbdiff_vector_1(char *db1, char *db2, 
		char          *key,
		struct dbdiff *df,
		char          *name, /* unique cv */
		const char    *label)
{
    int                   i1;
    int                   i2;
    int                   npairs1 = 0;
    int                   npairs2 = 0;
    struct db_pair       *pairs1;
    struct db_pair       *pairs2;
    struct _dbvars *v1 = NULL; /* cache of cvecs */
    struct _dbvars *v2 = NULL; 
    int                   retval = -1;
    cvec                 *vars;
    cg_var               *cv;
    int                   res;

    /* List all matches from both db's */
    if ((npairs1 = db_regexp(db1, key, __FUNCTION__, &pairs1, 0)) < 0)
	goto quit;
    if ((v1 = calloc(npairs1, sizeof(struct _dbvars))) == NULL){
	clicon_err(OE_DB, errno, "%s: calloc", __FUNCTION__);
	goto quit;
    }
    if ((npairs2 = db_regexp(db2, key, __FUNCTION__, &pairs2, 0)) < 0)
	goto quit;
    if ((v2 = calloc(npairs2, sizeof(struct _dbvars))) == NULL){
	clicon_err(OE_DB, errno, "%s: calloc", __FUNCTION__);
	goto quit;
    }
    for (i1 = 0; i1 < npairs1; i1++) {
	if ((vars = lvec2cvec (pairs1[i1].dp_val, pairs1[i1].dp_vlen)) == NULL)
	    goto quit;
	v1[i1].vars = vars;
	if ((cv = cvec_find(vars, name)) == NULL)
	    goto quit;
	if ((v1[i1].cv = cv) == NULL)
	    goto quit;
	v1[i1].key = pairs1[i1].dp_key;
    }
    qsort(v1, npairs1, sizeof(struct _dbvars), dbcmp);

    for (i2 = 0; i2 < npairs2; i2++){
	if ((vars = lvec2cvec (pairs2[i2].dp_val, pairs2[i2].dp_vlen)) == NULL)
	    goto quit;
	v2[i2].vars = vars;
	if ((cv = cvec_find(vars, name)) == NULL)
	    goto quit;
	if ((v2[i2].cv = cv) == NULL)
	    goto quit;
	v2[i2].key = pairs2[i2].dp_key;
    }
    qsort(v2, npairs2, sizeof(struct _dbvars), dbcmp);

    i1 = 0; i2 = 0;
    while (i1 < npairs1 && i2 < npairs2){
	res = cv_cmp(v1[i1].cv, v2[i2].cv);
	if (res<0){ /* in v1 but not v2 */
	    if (dbdiff_add(v1[i1++].key, NULL, 
			   DBDIFF_OP_FIRST, df, label) < 0)
		goto quit;
	}
	else
	    if (res>0){ /* in v2 but not v1 */
		if (dbdiff_add(NULL, v2[i2++].key, 
			       DBDIFF_OP_SECOND, df, label) < 0)
		    goto quit;
	    }
	    else{ /* equal */
		/* We have a match. Now compare all values */
		if (lv_matchvar (v1[i1].vars, v2[i2].vars, 1) == 0){
		    /* No, not equal, it has changed */
		    if (dbdiff_add(v1[i1].key, v2[i2].key, 
				   DBDIFF_OP_BOTH, df, label) < 0)
			goto quit;
		}
		i1++; i2++;
	    }
    }
    /* Now check if in any rests from one or the other */
    while (i1 < npairs1) /* in v1 but not v2 */
	if (dbdiff_add(v1[i1++].key, NULL, 
		       DBDIFF_OP_FIRST, df, label) < 0)
	    goto quit;
    while (i2 < npairs2) /* in v2 but not v1 */
	if (dbdiff_add(NULL, v2[i2++].key, 
		       DBDIFF_OP_SECOND, df, label) < 0)
	    goto quit;
    retval = 0;
  quit:
    if (v1){
	for (i1 = 0; i1 < npairs1; i1++) 
	    if (v1[i1].vars)
		cvec_free (v1[i1].vars);
	free(v1);
    }
    if (v2){
	for (i2 = 0; i2 < npairs2; i2++) 
	    if (v2[i2].vars)
		cvec_free (v2[i2].vars);
	free(v2);
    }
    unchunk_group(__FUNCTION__);
    return retval;
}	    

/*!
 * \brief
 *
 * Given two databases, db1 and db2, typically running (db1) and candidate (db2),
 * compute differences and return a db_diff structures, containing a list of entities,
 * each stating a database symbol and how it diffs.
   +---------------+     +---------------+  
   |   dbdiff      |---->|    dbdiff_ent |  [key1, key2, add/change/rm] (dfe_)
   +---------------+     +---------------+  
   (df_) from dbdiff(),   (dfe_)
 * 
 * The returned dfdiff structure is freed using unchunk_group.
 * Note: the order of the entries are according to the database spec (which in turn
 * is alphabetical).
 * Args:
 * IN     db1         database 1, typically running
 * IN     db2         database 2, typically candidate
 * IN     label       label for chunk memory handling
 * IN     db_spec     database specification
 * OUT    df          dbdiff struct containing list of database changes
 */
int
db_diff(char *db1,     
	char *db2, 
	const char *label,
	struct db_spec *db_spec,
	struct dbdiff *df
    )
{
    char *basekey; 
    int retval = -1;
    struct db_spec *ds;
    char *key;
    
    /* Loop through database spec */
    for (ds=db_spec; ds; ds=ds->ds_next){
	if ((basekey = ds->ds_key) == NULL){
	    clicon_err(OE_DB, 0, "%s: No db key", __FUNCTION__);
	    goto quit;
	}
	
	/* Call relevant sub-routine to append new db-key(s) to list */
	if(key_isanyvector(basekey)) {	/* Vector key */
	    if ((key = db_gen_rxkey(basekey, __FUNCTION__)) == NULL)
		goto quit;
	    /* if ds has one unique + it is a string, then optimize */
            {
		cvec   *vh = db_spec2cvec(ds);
		cg_var *v = NULL;
		char   *name = NULL;
		int     i=0;
		while ((v = cvec_each(vh, v))) 
		    if (cv_flag(v, V_UNIQUE)){
			i++;
			name = cv_name_get(v);			    
		    }
		if (i==1 && name){ /* optimize */
		    if (dbdiff_vector_1(db1, db2, key, df, name, label) < 0)
			goto quit;
		}
		else
		    if (dbdiff_vector(db1, db2, key, df, label) < 0)
			goto quit;
	    }
	} else {					/* Single key */
	    if (dbdiff_single(db1, db2, basekey, df, label) < 0)
		goto quit;
	}
	
    } /* for() */
    retval = 0;
quit:
    unchunk_group(__FUNCTION__);
    return retval;
}
