/*
 *
  Copyright (C) 2009-2015 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <syslog.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

/* Command line options to be passed to getopt(3) */
#define DBCTRL_OPTS "hDd:pbn:r:m:Zxi"

/*! Write database contents to file, lvec database variant
 * @param[in]  dbspec  If set make a sanity check if key dont match (just)
 */
static int
dump_database_lvec(FILE       *f, 
		   char       *dbname, 
		   char       *rxkey, 
		   int         brief)
{
    int             retval = 0;
    int             npairs;
    struct db_pair *pairs;
    
    /* Default is match all */
    if (rxkey == NULL)
	rxkey = "^.*$";

    /* Get all keys/values for vector */
    if ((npairs = db_regexp(dbname, rxkey, __FUNCTION__, &pairs, 0)) < 0)
        return -1;
    
    for (npairs--; npairs >= 0; npairs--) {

	fprintf(f, "%s\n", pairs[npairs].dp_key);
	if (!brief)
	    fprintf(f, "--------------------\n");
	if (brief)
	    continue;
	if(key_isvector_n(pairs[npairs].dp_key) ||
	   key_iskeycontent(pairs[npairs].dp_key)) {
	    fprintf(f, "\ttype: number\tlen: %d\tdata: %d\n",
		   (int)sizeof(int),
		   *(int *)pairs[npairs].dp_val);
	}
	else{ 
	    if(lv_dump(f, pairs[npairs].dp_val, pairs[npairs].dp_vlen) < 0){
		retval = -1;
		break;
	    }
	}
	fprintf(f, "\n");
    }
    unchunk_group(__FUNCTION__);
    return retval;
}

/*! Write database contents to file, xml database variant
 * @param[in]  dbspec  If set make a sanity check if key dont match (just)
 */
static int
dump_database_xml(FILE       *f,
		  char       *dbname, 
		  char       *rxkey)
{
    int             retval = 0;
    int             npairs;
    struct db_pair *pairs;

    /* Default is match all */
    if (rxkey == NULL)
	rxkey = "^.*$";

    /* Get all keys/values for vector */
    if ((npairs = db_regexp(dbname, rxkey, __FUNCTION__, &pairs, 0)) < 0)
        return -1;
    
    for (npairs--; npairs >= 0; npairs--) 
	fprintf(f, "%s %s\n", pairs[npairs].dp_key,
		pairs[npairs].dp_val?pairs[npairs].dp_val:"");
    unchunk_group(__FUNCTION__);
    return retval;
}


/*
 * remove_entry
 */
static int
remove_entry(char *dbname, char *key)
{
  return clicon_dbdel(dbname, key);
}

/*
 * usage
 */
static void
usage(char *argv0)
{
    fprintf(stderr, "usage:%s\n"
	    "where options are\n"
            "\t-h\t\tHelp\n"
            "\t-D\t\tDebug\n"
            "\t-d <dbname>\tDatabase name (default: running_db)\n"
    	    "\t-p\t\tDump database on stdout\n"
    	    "\t-b\t\tBrief output, just print keys. Combine with -p or -m\n"
	    "\t-n \"<key> <var=%%T{value}> <var=...>\"\tAdd database entry\n"
            "\t-r <key>\tRemove database entry\n"
	    "\t-m <regexp key>\tMatch regexp key in database\n"
    	    "\t-Z\t\tDelete database\n"
    	    "\t-x\t\tXML database, not lvec (some options dont work eg '-n')\n"
    	    "\t-i\t\tInit database\n",
	    argv0
	    );
    exit(0);
}

int
main(int argc, char **argv)
{
    char             c;
    int              zapdb;
    int              initdb;
    int              dumpdb;
    int              addent;
    int              rment;
    char            *matchkey = NULL;
    char            *addstr;
    char             rmkey[MAXPATHLEN];
    int              brief;
    char             dbname[MAXPATHLEN] = {0,};
    int              use_syslog;
    dbspec_key      *dbspec = NULL;
    int              xmldb;

    /* In the startup, logs to stderr & debug flag set later */
    clicon_log_init(__PROGRAM__, LOG_INFO, CLICON_LOG_STDERR); 

    /* Defaults */
    zapdb      = 0;
    initdb     = 0;
    dumpdb     = 0;
    addent     = 0;
    rment      = 0;
    brief      = 0;
    use_syslog = 0;
    addstr     = NULL;
    xmldb      = 0;
    memset(rmkey, '\0', sizeof(rmkey));

    /* getopt in two steps, first find config-file before over-riding options. */
    while ((c = getopt(argc, argv, DBCTRL_OPTS)) != -1)
	switch (c) {
	case '?' :
	case 'h' : /* help */
	    usage(argv[0]);
	    break;
	case 'D' : /* debug */
	    debug = 1;	
	    break;
	 case 'S': /* Log on syslog */
	     use_syslog = 1;
	     break;
	}
    /* 
     * Logs, error and debug to stderr or syslog, set debug level
     */
    clicon_log_init(__PROGRAM__, debug?LOG_DEBUG:LOG_INFO, 
		    use_syslog?CLICON_LOG_SYSLOG:CLICON_LOG_STDERR); 
    clicon_debug_init(debug, NULL); 

    /* Now rest of options */   
    optind = 1;
    while ((c = getopt(argc, argv, DBCTRL_OPTS)) != -1)
	switch (c) {
	case 'Z': /* Zap database */
	    zapdb++;
	    break;
	case 'i': /* Init database */
	    initdb++;
	    break;
	case 'p': /* Dump/print database */
	    dumpdb++;
	    break;
	case 'b': /* Dump/print/match database  brief (combone w -p or -m) */
	    brief++;
	    break;
	case 'd': /* dbname */
	    if (!optarg || sscanf(optarg, "%s", dbname) != 1)
	        usage(argv[0]);
	    break;
	case 'n': /* add database entry */
	  if (!optarg || !strlen(optarg) || (addstr = strdup(optarg)) == NULL)
	        usage(argv[0]);
	    addent++;
	    break;
	case 'r':
	     if (!optarg || sscanf(optarg, "%s", rmkey) != 1)
		 usage(argv[0]);
	     rment++;
	     break;
	case 'm':
	  if (!optarg || !strlen(optarg) || (matchkey = strdup(optarg)) == NULL)
	        usage(argv[0]);
	    dumpdb++;
	    break;
	case 'x' : /* xml database */
	    xmldb++;	
	    break;
	case 'D':  /* Processed earlier, ignore now. */
	case 'S':
	    break;
	default:
	    usage(argv[0]);
	    break;
	}
    argc -= optind;
    argv += optind;

    if (*dbname == '\0'){
	clicon_err(OE_FATAL, 0, "database not specified (with -d <db>): %s");
	goto quit;
    }
    if (dumpdb){
	if (xmldb){
	    if (dump_database_xml(stdout, dbname, matchkey)) {
		fprintf(stderr, "Match error\n");
		goto quit;
	    }
	}
	else
	    if (dump_database_lvec(stdout, dbname, matchkey, brief)) {
		fprintf(stderr, "Match error\n");
		goto quit;
	    }
    }
    if (addent) /* add entry */
	if (db_lv_op(dbspec, dbname, LV_SET, addstr, NULL) < 0){
	    fprintf(stderr, "Failed to add entry\n");
	    goto quit;
	}
    if (rment)
        if (remove_entry(dbname, rmkey) < 0)
	    goto quit;
    if (zapdb) /* remove databases */
	unlink(dbname);
    if (initdb)
	if (db_init(dbname) < 0)
	    goto quit;

  quit:
    db_spec_free(dbspec);
    return 0;
}
